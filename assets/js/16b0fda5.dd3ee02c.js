(self.webpackChunkhhow_09_github_io=self.webpackChunkhhow_09_github_io||[]).push([[3834],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return s},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),m=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},s=function(e){var t=m(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=m(a),d=r,g=u["".concat(c,".").concat(d)]||u[d]||p[d]||l;return a?n.createElement(g,o(o({ref:t},s),{},{components:a})):n.createElement(g,o({ref:t},s))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var m=2;m<l;m++)o[m]=a[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8269:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return i},metadata:function(){return c},toc:function(){return m},default:function(){return p}});var n=a(2122),r=a(9756),l=(a(7294),a(3905)),o=["components"],i={},c={unversionedId:"programming/memory-allocations-golang",id:"programming/memory-allocations-golang",isDocsHomePage:!1,title:"Understanding Memory Allocations in Go",description:"Links",source:"@site/docs/programming/3-memory-allocations-golang.md",sourceDirName:"programming",slug:"/programming/memory-allocations-golang",permalink:"/programming/memory-allocations-golang",editUrl:"https://github.com/hhow09/hhow09.github.io/blob/source/docs/programming/3-memory-allocations-golang.md",version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Concurrency vs. Parallelism v.s. Coroutine",permalink:"/programming/concurrent-vs-parallelism"},next:{title:"Props Drilling and State Management",permalink:"/react/react-prop-drilling"}},m=[{value:"Links",id:"links",children:[]},{value:"Stack v.s. Heap",id:"stack-vs-heap",children:[]},{value:"Stack",id:"stack",children:[{value:"Stack Frame",id:"stack-frame",children:[]},{value:"Function and Stack",id:"function-and-stack",children:[]}]},{value:"Heap",id:"heap",children:[]},{value:"Process Memory Layout in Golang",id:"process-memory-layout-in-golang",children:[]},{value:"How do we know when a variable is allocated to the heap?",id:"how-do-we-know-when-a-variable-is-allocated-to-the-heap",children:[]},{value:"Garbage collection (GC)",id:"garbage-collection-gc",children:[]}],s={toc:m};function p(e){var t=e.components,i=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,n.Z)({},s,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"links"},"Links"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d"},"Understanding Allocations in Go")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.guru99.com/stack-vs-heap.html"},"Stack vs Heap: Know the Difference")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://medium.com/safetycultureengineering/an-overview-of-memory-management-in-go-9a72ec7c76a8"},"An overview of memory management in Go")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://youtu.be/sTFJtxJXkaY"},"Golang Tutorial 3 - Golang pointers explained, once and for all"))),(0,l.kt)("h2",{id:"stack-vs-heap"},"Stack v.s. Heap"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Stack"),(0,l.kt)("th",{parentName:"tr",align:null},"Heap"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Type of data structures"),(0,l.kt)("td",{parentName:"tr",align:null},"A stack is a linear data structure."),(0,l.kt)("td",{parentName:"tr",align:null},"Heap is a hierarchical data structure.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Access speed"),(0,l.kt)("td",{parentName:"tr",align:null},"High-speed access"),(0,l.kt)("td",{parentName:"tr",align:null},"Slower compared to stack")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Space management"),(0,l.kt)("td",{parentName:"tr",align:null},"Space managed efficiently by OS so memory will never become fragmented."),(0,l.kt)("td",{parentName:"tr",align:null},"Heap Space not used as efficiently. Memory can become fragmented as blocks of memory first allocated and then freed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Access"),(0,l.kt)("td",{parentName:"tr",align:null},"Local variables only"),(0,l.kt)("td",{parentName:"tr",align:null},"It allows you to access variables globally.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Limit of space size"),(0,l.kt)("td",{parentName:"tr",align:null},"Limit on stack size dependent on OS."),(0,l.kt)("td",{parentName:"tr",align:null},"Does not have a specific limit on memory size.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Resize"),(0,l.kt)("td",{parentName:"tr",align:null},"Variables cannot be resized"),(0,l.kt)("td",{parentName:"tr",align:null},"Variables can be resized.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Memory Allocation"),(0,l.kt)("td",{parentName:"tr",align:null},"Memory is allocated in a contiguous block."),(0,l.kt)("td",{parentName:"tr",align:null},"Memory is allocated in any random order.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Allocation and Deallocation"),(0,l.kt)("td",{parentName:"tr",align:null},"Automatically done by compiler instructions."),(0,l.kt)("td",{parentName:"tr",align:null},"It is manually done by the programmer.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Deallocation"),(0,l.kt)("td",{parentName:"tr",align:null},"Does not require to de-allocate variables."),(0,l.kt)("td",{parentName:"tr",align:null},"Explicit de-allocation is needed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Cost"),(0,l.kt)("td",{parentName:"tr",align:null},"Less"),(0,l.kt)("td",{parentName:"tr",align:null},"More")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Implementation"),(0,l.kt)("td",{parentName:"tr",align:null},"A stack can be implemented in 3 ways simple array based, using dynamic memory, and Linked list based."),(0,l.kt)("td",{parentName:"tr",align:null},"Heap can be implemented using array and trees.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Main Issue"),(0,l.kt)("td",{parentName:"tr",align:null},"Shortage of memory"),(0,l.kt)("td",{parentName:"tr",align:null},"Memory fragmentation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Locality of reference"),(0,l.kt)("td",{parentName:"tr",align:null},"Automatic compile time instructions."),(0,l.kt)("td",{parentName:"tr",align:null},"Adequate")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Flexibility"),(0,l.kt)("td",{parentName:"tr",align:null},"Fixed size"),(0,l.kt)("td",{parentName:"tr",align:null},"Resizing is possible")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Access time"),(0,l.kt)("td",{parentName:"tr",align:null},"Faster"),(0,l.kt)("td",{parentName:"tr",align:null},"Slower")))),(0,l.kt)("h2",{id:"stack"},"Stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We don\u2019t need to garbage collection on stack")),(0,l.kt)("h3",{id:"stack-frame"},"Stack Frame"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A call stack is composed of 1 or many several ",(0,l.kt)("strong",{parentName:"li"},"stack frame"),"s. "),(0,l.kt)("li",{parentName:"ul"},"Each stack frame corresponds to a call to a function or procedure which has not yet terminated with a return."),(0,l.kt)("li",{parentName:"ul"},"Function arguments, local variables and return address are stored in stack frame")),(0,l.kt)("h3",{id:"function-and-stack"},"Function and Stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Each function call pushes a new frame to the stack"),(0,l.kt)("li",{parentName:"ul"},"Each returning function pops from the stack.")),(0,l.kt)("h2",{id:"heap"},"Heap"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the heap contains values that are referenced outside of a function."),(0,l.kt)("li",{parentName:"ul"},"When the programmer defines an object that gets placed on the heap, the needed amount of memory is allocated and a pointer to it is returned."),(0,l.kt)("li",{parentName:"ul"},"As a program runs, the heap will continue to grow as objects are added unless the heap is cleaned up.")),(0,l.kt)("h2",{id:"process-memory-layout-in-golang"},"Process Memory Layout in Golang"),(0,l.kt)("p",null,(0,l.kt)("img",{src:a(2542).Z})),(0,l.kt)("h2",{id:"how-do-we-know-when-a-variable-is-allocated-to-the-heap"},(0,l.kt)("a",{parentName:"h2",href:"https://go.dev/doc/faq#stack_or_heap"},"How do we know when a variable is allocated to the heap?")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame."),(0,l.kt)("li",{parentName:"ul"},"However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid ",(0,l.kt)("strong",{parentName:"li"},"dangling pointer errors"),".")),(0,l.kt)("h2",{id:"garbage-collection-gc"},"Garbage collection (GC)"))}p.isMDXComponent=!0},2542:function(e,t,a){"use strict";t.Z=a.p+"assets/images/golang-memory-layout-9badc344de6d51392eaac67cce12e4e8.jpeg"}}]);