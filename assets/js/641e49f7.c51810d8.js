(self.webpackChunkhhow_09_github_io=self.webpackChunkhhow_09_github_io||[]).push([[7295],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return p},kt:function(){return u}});var r=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=r.createContext({}),m=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=m(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=m(a),u=i,k=d["".concat(s,".").concat(u)]||d[u]||c[u]||n;return a?r.createElement(k,l(l({ref:t},p),{},{components:a})):r.createElement(k,l({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,l=new Array(n);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var m=2;m<n;m++)l[m]=a[m];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4276:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return o},metadata:function(){return s},toc:function(){return m},default:function(){return c}});var r=a(2122),i=a(9756),n=(a(7294),a(3905)),l=["components"],o={},s={unversionedId:"data-structure/lsm-tree",id:"data-structure/lsm-tree",isDocsHomePage:!1,title:"LSM Tree",description:"Design a simple key value database",source:"@site/docs/data-structure/4-lsm-tree.md",sourceDirName:"data-structure",slug:"/data-structure/lsm-tree",permalink:"/data-structure/lsm-tree",editUrl:"https://github.com/hhow09/hhow09.github.io/blob/source/docs/data-structure/4-lsm-tree.md",version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"B-Tree",permalink:"/data-structure/b-tree"},next:{title:"How to model one-to-many relationships in DynamoDB",permalink:"/db/dynamodb-modeling"}},m=[{value:"Design a simple key value database",id:"design-a-simple-key-value-database",children:[{value:"First",id:"first",children:[]},{value:"Optimization",id:"optimization",children:[]}]},{value:"What is LSM Tree",id:"what-is-lsm-tree",children:[]},{value:"Components",id:"components",children:[{value:"1. Memtable (in memory)",id:"1-memtable-in-memory",children:[]},{value:"2. SSTable (in disk)",id:"2-sstable-in-disk",children:[]},{value:"3. WAL (write ahead log)",id:"3-wal-write-ahead-log",children:[]}]},{value:"Access Pattern",id:"access-pattern",children:[{value:"Read",id:"read",children:[]},{value:"Write",id:"write",children:[]},{value:"Delete",id:"delete",children:[]}]},{value:"Compaction strategies",id:"compaction-strategies",children:[]},{value:"Optimization",id:"optimization-1",children:[{value:"Read Optimization",id:"read-optimization",children:[]}]},{value:"Pros",id:"pros",children:[]},{value:"Cons",id:"cons",children:[]},{value:"Reference",id:"reference",children:[]}],p={toc:m};function c(e){var t=e.components,o=(0,i.Z)(e,l);return(0,n.kt)("wrapper",(0,r.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"design-a-simple-key-value-database"},"Design a simple key value database"),(0,n.kt)("h3",{id:"first"},"First"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Write: ",(0,n.kt)("strong",{parentName:"li"},"appending key-value pairs")," in a ",(0,n.kt)("strong",{parentName:"li"},"file as the storage unit"),".",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Complexity: ",(0,n.kt)("inlineCode",{parentName:"li"},"O(1)")))),(0,n.kt)("li",{parentName:"ul"},"Read: with a target key ",(0,n.kt)("inlineCode",{parentName:"li"},"k"),", scan through every k-v pairs. ",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Complexity: ",(0,n.kt)("inlineCode",{parentName:"li"},"O(N)")," (bad)")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"k1: v1\nk2: v2\n...\n...\n...\n")),(0,n.kt)("h3",{id:"optimization"},"Optimization"),(0,n.kt)("p",null,"To optimize read performance, we could use a hash map storing the ",(0,n.kt)("inlineCode",{parentName:"p"},"key-offset")," for indexing. Now we have ",(0,n.kt)("inlineCode",{parentName:"p"},"O(1)")," read. The limitation would be ",(0,n.kt)("strong",{parentName:"p"},"hash map")," must totally fit in memroy size."),(0,n.kt)("p",null,"This is the core idea of ",(0,n.kt)("a",{parentName:"p",href:"http://highscalability.com/blog/2011/1/10/riaks-bitcask-a-log-structured-hash-table-for-fast-keyvalue.html"},"Bitcask")),(0,n.kt)("p",null,(0,n.kt)("img",{src:a(7264).Z})),(0,n.kt)("h2",{id:"what-is-lsm-tree"},"What is LSM Tree"),(0,n.kt)("p",null,(0,n.kt)("img",{src:a(1970).Z})),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"is a disk friendly data structure."),(0,n.kt)("li",{parentName:"ol"},"is designed to reduce disk I/O (bottleneck) with ",(0,n.kt)("strong",{parentName:"li"},"memory-buffered writes")),(0,n.kt)("li",{parentName:"ol"},"is used when dealing with ",(0,n.kt)("strong",{parentName:"li"},"write-heavy")," workloads."),(0,n.kt)("li",{parentName:"ol"},"is used by Cassandra / Dynomo DB, HBase, Riak, Lucene, Rocks DB"),(0,n.kt)("li",{parentName:"ol"},"consisted of in-memory part (memtable) + disk part (SSTable)"),(0,n.kt)("li",{parentName:"ol"},"The term ",(0,n.kt)("strong",{parentName:"li"},"merge")," refers to the algorithm with which data is managed in the structure."),(0,n.kt)("li",{parentName:"ol"},"The term ",(0,n.kt)("strong",{parentName:"li"},"tree")," in its name comes from the fact that data is organized into multiple levels similar to devices in the storage hierarchy in a typical computer where the top level device holds smaller subset of data and is faster to access while the lower levels holds larger segments of data and is slow to access.")),(0,n.kt)("h2",{id:"components"},"Components"),(0,n.kt)("h3",{id:"1-memtable-in-memory"},"1. Memtable (in memory)"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"LSMTree starts with an in-memory balanced tree (or hash table)."),(0,n.kt)("li",{parentName:"ul"},"What data structure to use for the Memtable typically depends upon the performance requirements but must have a property that it should provide a sorted iteration over its contents. "),(0,n.kt)("li",{parentName:"ul"},"When Memtable grows to a certain threshold, srot and flush into disk as a immutable SSTable"),(0,n.kt)("li",{parentName:"ul"},"Memtable keeps the latest data.")),(0,n.kt)("h3",{id:"2-sstable-in-disk"},"2. SSTable (in disk)"),(0,n.kt)("p",null,(0,n.kt)("img",{src:a(4e3).Z})),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"SSTable is the disk component for LSM-tree.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"SSTable is immutable.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"contains a list of ",(0,n.kt)("strong",{parentName:"p"},"data blocks")," and an ",(0,n.kt)("strong",{parentName:"p"},"index block")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"data block stores key-value pairs ordered by keys."),(0,n.kt)("li",{parentName:"ul"},"index block stores the key ranges of all data blocks."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"when a SSTable is read, index block will be loaded into memory for binary search.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"index block stores the key ranges of all data blocks."))),(0,n.kt)("h3",{id:"3-wal-write-ahead-log"},"3. WAL (write ahead log)"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"for crash recovery"),(0,n.kt)("li",{parentName:"ul"},"before actually write to memtable, write first to WAL")),(0,n.kt)("h2",{id:"access-pattern"},"Access Pattern"),(0,n.kt)("h3",{id:"read"},"Read"),(0,n.kt)("p",null,"search memtable first, if not found, search disk segments from latest to oldest"),(0,n.kt)("h3",{id:"write"},"Write"),(0,n.kt)("p",null,"write data into WAL, then write to Memtable."),(0,n.kt)("h3",{id:"delete"},"Delete"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"add a special ",(0,n.kt)("strong",{parentName:"li"},"tombstone mark"),", means record is delete."),(0,n.kt)("li",{parentName:"ul"},"is also a append operation"),(0,n.kt)("li",{parentName:"ul"},"data with ",(0,n.kt)("strong",{parentName:"li"},"tombstone mark")," will be discarded during compaction process."),(0,n.kt)("li",{parentName:"ul"},"data with ",(0,n.kt)("strong",{parentName:"li"},"tombstone mark")," will be regarded as ",(0,n.kt)("inlineCode",{parentName:"li"},"NULL")," in read.")),(0,n.kt)("h2",{id:"compaction-strategies"},"Compaction strategies"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The core algorithm utilized by compaction is the ",(0,n.kt)("strong",{parentName:"li"},"k-way merge sort")," algorithm adapted to SSTables."),(0,n.kt)("li",{parentName:"ul"},"Compaction strategy impacts the read/write performance and the space utilization in the LSM Tree. ")),(0,n.kt)("p",null,"//TODO\n",(0,n.kt)("a",{parentName:"p",href:"https://dev.to/creativcoder/what-is-a-lsm-tree-3d75"},"https://dev.to/creativcoder/what-is-a-lsm-tree-3d75")),(0,n.kt)("h2",{id:"optimization-1"},"Optimization"),(0,n.kt)("h3",{id:"read-optimization"},"Read Optimization"),(0,n.kt)("p",null,(0,n.kt)("img",{src:a(8795).Z})),(0,n.kt)("h4",{id:"index"},"index"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"We can have an in-memory index (a hashmap) which contains a mapping of keys to their byte offset in the file. However it's not practical for it's using too much memory"),(0,n.kt)("li",{parentName:"ul"},"What practical implementations do is that they maintain a Sparse Index of each SSTable which contains only the subset of keys in memory and utilize binary search to quickly skip ranges and narrow the search space.")),(0,n.kt)("h4",{id:"fence-pointer"},(0,n.kt)("strong",{parentName:"h4"},"Fence pointer")),(0,n.kt)("p",null,"when read SSTable, use in-memory fence pointer for binary search to reduce disk I/O."),(0,n.kt)("h4",{id:"bloom-filter"},"Bloom filter"),(0,n.kt)("p",null,"to fast filter unexist key."),(0,n.kt)("h4",{id:"merge-frequency"},"merge frequency"),(0,n.kt)("h2",{id:"pros"},"Pros"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"fast write since append only")),(0,n.kt)("h2",{id:"cons"},"Cons"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Range Query: still need to look up one by one."),(0,n.kt)("li",{parentName:"ol"},"compaction process affects read and write performance"),(0,n.kt)("li",{parentName:"ol"},"extra space required to perform compaction")),(0,n.kt)("h2",{id:"reference"},"Reference"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://codingnote.cc/zh-tw/p/566494/"},"\u7c21\u8ff0LSM-Tree")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://dev.to/creativcoder/what-is-a-lsm-tree-3d75"},"What is a LSM Tree?")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/"},"Designing Data-Intensive Applications Ch3")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://youtu.be/b6SI8VbcT4w"},"Scaling Write-Intensive Key-Value Stores")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://highscalability.com/blog/2011/1/10/riaks-bitcask-a-log-structured-hash-table-for-fast-keyvalue.html"},"Riak's Bitcask - A Log-Structured Hash Table For Fast Key/Value Data"))))}c.isMDXComponent=!0},7264:function(e,t,a){"use strict";t.Z=a.p+"assets/images/bitcask-write-6015a0a30ea0a23370bb45999767f5f8.jpeg"},1970:function(e,t,a){"use strict";t.Z=a.p+"assets/images/lsm-tree-c83305155192b4ad1502845f5c881998.png"},8795:function(e,t,a){"use strict";t.Z=a.p+"assets/images/read-optimization-078f30608a161c76dd82e69f20f4e6ad.png"},4e3:function(e,t,a){"use strict";t.Z=a.p+"assets/images/sstable-074ce681af39827fb7e3e5d4c2edd81a.png"}}]);