(self.webpackChunkhhow_09_github_io=self.webpackChunkhhow_09_github_io||[]).push([[3441],{3905:function(e,t,r){"use strict";r.d(t,{Zo:function(){return d},kt:function(){return u}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=p(r),u=a,h=m["".concat(l,".").concat(u)]||m[u]||c[u]||s;return r?n.createElement(h,o(o({ref:t},d),{},{components:r})):n.createElement(h,o({ref:t},d))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,o=new Array(s);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var p=2;p<s;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},8800:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return p},default:function(){return c}});var n=r(2122),a=r(9756),s=(r(7294),r(3905)),o=["components"],i={},l={unversionedId:"web-dev/ssr-stream",id:"web-dev/ssr-stream",isDocsHomePage:!1,title:"Node.js Streaming Server-Side Rendering",description:"TL:DR",source:"@site/docs/web-dev/8-ssr-stream.md",sourceDirName:"web-dev",slug:"/web-dev/ssr-stream",permalink:"/web-dev/ssr-stream",editUrl:"https://github.com/hhow09/hhow09.github.io/blob/source/docs/web-dev/8-ssr-stream.md",version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Webpack Overview",permalink:"/web-dev/webpack-overview"}},p=[{value:"TL:DR",id:"tldr",children:[{value:"Review the rendering work flow",id:"review-the-rendering-work-flow",children:[]}]},{value:"Intro - Different Types of Rendering Flow",id:"intro---different-types-of-rendering-flow",children:[{value:"1. Client Side Rendering",id:"1-client-side-rendering",children:[]},{value:"2. Server Side Rendering",id:"2-server-side-rendering",children:[]}]},{value:"Terms",id:"terms",children:[{value:"flush()",id:"flush",children:[]},{value:"React.hydrate()",id:"reacthydrate",children:[]},{value:"Rehydration",id:"rehydration",children:[]},{value:"ReactDOMServer.renderToNodeStream(element)",id:"reactdomserverrendertonodestreamelement",children:[]}]},{value:"Streaming SSR",id:"streaming-ssr",children:[{value:"Normal SSR (top) v.s. Streaming SSR (bottom)",id:"normal-ssr-top-vs-streaming-ssr-bottom",children:[]},{value:"Pros &amp; Cons",id:"pros--cons",children:[]},{value:"Example: GoogleChromeLabs/progressive-rendering-frameworks-samples",id:"example-googlechromelabsprogressive-rendering-frameworks-samples",children:[]}]},{value:"Progressive Hydration",id:"progressive-hydration",children:[{value:"Pros",id:"pros",children:[]},{value:"Example: progressive-hydration",id:"example-progressive-hydration",children:[]}]},{value:"Ndoe.js Stream",id:"ndoejs-stream",children:[]},{value:"Reference",id:"reference",children:[]}],d={toc:p};function c(e){var t=e.components,i=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"tldr"},"TL:DR"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"React can be a lost faster than client side rendering."),(0,s.kt)("li",{parentName:"ul"},"Straming enables page performance to stay constant."),(0,s.kt)("li",{parentName:"ul"},"We need to think our page as separately renderable pieces."),(0,s.kt)("li",{parentName:"ul"},"The scenario is usually ",(0,s.kt)("strong",{parentName:"li"},"high performance server")," and ",(0,s.kt)("strong",{parentName:"li"},"lower performace client browser/device")," and ",(0,s.kt)("strong",{parentName:"li"},"slow network"))),(0,s.kt)("h3",{id:"review-the-rendering-work-flow"},"Review the rendering work flow"),(0,s.kt)("p",null,(0,s.kt)("img",{src:r(8334).Z})),(0,s.kt)("h2",{id:"intro---different-types-of-rendering-flow"},"Intro - Different Types of Rendering Flow"),(0,s.kt)("p",null,(0,s.kt)("img",{src:r(3235).Z})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"see more on ",(0,s.kt)("a",{parentName:"li",href:"https://developers.google.com/web/updates/2019/02/rendering-on-the-web"},"Rendering on the Web"))),(0,s.kt)("h3",{id:"1-client-side-rendering"},"1. Client Side Rendering"),(0,s.kt)("p",null,(0,s.kt)("img",{src:r(148).Z})),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"client request"),(0,s.kt)("li",{parentName:"ol"},"server returns small html with no info"),(0,s.kt)("li",{parentName:"ol"},"client request doc header and request JS and CSS"),(0,s.kt)("li",{parentName:"ol"},"client parse JS & CSS"),(0,s.kt)("li",{parentName:"ol"},"client browser painting meanwhile request for data from API"),(0,s.kt)("li",{parentName:"ol"},"API returns data"),(0,s.kt)("li",{parentName:"ol"},"client use ",(0,s.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/react-dom.html#render"},"ReactDOM.render()")," to revive the DOM once you have ",(0,s.kt)("strong",{parentName:"li"},"both Javascript and JSON data")),(0,s.kt)("li",{parentName:"ol"},"client shows full page and become interactive")),(0,s.kt)("h4",{id:"pros-and-cons"},"Pros and Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"pros: no need dynamic server"),(0,s.kt)("li",{parentName:"ul"},"cons: slow cuz jobs are done in serial"),(0,s.kt)("li",{parentName:"ul"},"cons: slow cuz parsing javascript is expensive")),(0,s.kt)("h3",{id:"2-server-side-rendering"},"2. Server Side Rendering"),(0,s.kt)("p",null,(0,s.kt)("img",{src:r(5270).Z})),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"client request"),(0,s.kt)("li",{parentName:"ol"},"server return only HTML header to client"),(0,s.kt)("li",{parentName:"ol"},"client request for JS and CSS based on HTML header"),(0,s.kt)("li",{parentName:"ol"},"server meanwhile make request to API server"),(0,s.kt)("li",{parentName:"ol"},"server load data on the server side and use ",(0,s.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/react-dom-server.html#rendertostring"},"ReactDOMServer.renderToString()")," to create HTML markup"),(0,s.kt)("li",{parentName:"ol"},"client parsing JS and CSS"),(0,s.kt)("li",{parentName:"ol"},"server send the data down in a script tag or via HTTP/2 Server Push. (",(0,s.kt)("strong",{parentName:"li"},"first contentful paint"),")"),(0,s.kt)("li",{parentName:"ol"},"client become interactive when step 6 is done (",(0,s.kt)("strong",{parentName:"li"},"Time to Interactive"),")")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"noted that:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"3 and 4 can be parallel"),(0,s.kt)("li",{parentName:"ul"},"5 and 6 can be parallel")))),(0,s.kt)("h4",{id:"pros-and-cons-1"},"Pros and Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"pros: faster than client side rendering cuz job can be done in parallel"),(0,s.kt)("li",{parentName:"ul"},"pros: faster than client side rendering cuz server usually has better performance than client"),(0,s.kt)("li",{parentName:"ul"},"cons: needs dynamic web server"),(0,s.kt)("li",{parentName:"ul"},"cons: Don't scale, ",(0,s.kt)("a",{parentName:"li",href:"https://web.dev/interactive/"},"Time to Interactive")," increase when more feature (JS and CSS) added on page.")),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"terms"},"Terms"),(0,s.kt)("h3",{id:"flush"},(0,s.kt)("a",{parentName:"h3",href:"http://expressjs.com/en/resources/middleware/compression.html"},"flush()")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A res.flush method is added to force partially compressed response to be flushed to the client.")),(0,s.kt)("h3",{id:"reacthydrate"},(0,s.kt)("a",{parentName:"h3",href:"https://reactjs.org/docs/react-dom.html#hydrate"},"React.hydrate()")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Same as ",(0,s.kt)("inlineCode",{parentName:"li"},"render()"),", but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup.")),(0,s.kt)("h3",{id:"rehydration"},"Rehydration"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\u201cbooting up\u201d JavaScript views on the client such that they reuse the server-rendered HTML\u2019s DOM tree and data.")),(0,s.kt)("h3",{id:"reactdomserverrendertonodestreamelement"},(0,s.kt)("a",{parentName:"h3",href:"https://reactjs.org/docs/react-dom-server.html#rendertonodestream"},"ReactDOMServer.renderToNodeStream(element)")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Returns a Readable stream that outputs an HTML string."),(0,s.kt)("li",{parentName:"ul"},"The HTML output by this stream is exactly equal to what ",(0,s.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/react-dom-server.html#rendertostring"},"ReactDOMServer.renderToString")," would return."),(0,s.kt)("li",{parentName:"ul"},"The function will only work on the server to render HTML as a stream."),(0,s.kt)("li",{parentName:"ul"},"The client receiving this stream can subsequently call ",(0,s.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/react-dom.html#hydrate"},"ReactDOM.hydrate()")," to hydrate the page and make it interactive.")),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"streaming-ssr"},"Streaming SSR"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"streaming implies chunks of HTML are streamed from the node server to the client as they are generated."),(0,s.kt)("li",{parentName:"ul"},"we need to break down each part of the page and send them to client respectively"),(0,s.kt)("li",{parentName:"ul"},"overall process seems like multiple chunks of normal SSRs."),(0,s.kt)("li",{parentName:"ul"},"can combine with ",(0,s.kt)("a",{parentName:"li",href:"#progressive-hydration"},"progressive hydration")," to increase ",(0,s.kt)("a",{parentName:"li",href:"https://web.dev/interactive/"},"Time to Interactive")," on client side")),(0,s.kt)("h3",{id:"normal-ssr-top-vs-streaming-ssr-bottom"},"Normal SSR (top) v.s. Streaming SSR (bottom)"),(0,s.kt)("p",null,(0,s.kt)("img",{src:r(3130).Z})),(0,s.kt)("h3",{id:"pros--cons"},"Pros & Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"pros: Fastest ",(0,s.kt)("a",{parentName:"li",href:"https://web.dev/first-contentful-paint/"},"First Contentful Paint"),", fastest ",(0,s.kt)("a",{parentName:"li",href:"https://web.dev/interactive/"},"Time to Interactive")),(0,s.kt)("li",{parentName:"ul"},"pros: As the page scales up in content and JS, above the fold load stays constant."),(0,s.kt)("li",{parentName:"ul"},"pros: More fault tolerant of misbehaving data service further down the page."),(0,s.kt)("li",{parentName:"ul"},"pros: Streaming enables Node.js server to render multiple requests at the same time and prevents heavier requests from blocking lighter requests for a long time."),(0,s.kt)("li",{parentName:"ul"},"cons: intra-page code splitting is complicated"),(0,s.kt)("li",{parentName:"ul"},"cons: webpack doesn't yet support multiple CSS chunks for one entry chunk (2017 video, need to check)"),(0,s.kt)("li",{parentName:"ul"},"cons: tricky to implement perfect optimization of resource loading")),(0,s.kt)("h3",{id:"example-googlechromelabsprogressive-rendering-frameworks-samples"},"Example: ",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples"},"GoogleChromeLabs/progressive-rendering-frameworks-samples")),(0,s.kt)("h4",{id:"react-streaming-ssrappserverjs"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples/blob/master/react-streaming-ssr/app/server.js"},"react-streaming-ssr/app/server.js")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import React from "react";\nimport ReactDOMServer from "react-dom/server";\nimport App from "./components/app";\n\nexport default async function ssr({ streaming, ...props }) {\n    if (streaming) {\n        return ReactDOMServer.renderToNodeStream(<App {...props} />);\n    } else {\n        return ReactDOMServer.renderToString(<App {...props} />);\n    }\n}\n')),(0,s.kt)("h4",{id:"react-streaming-ssrserverjs"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples/blob/master/react-streaming-ssr/server.js"},"react-streaming-ssr/server.js")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},'app.get("/streaming", async (request, response) => {\n    try {\n        const stream = await ssr({\n            url: request.url,\n        });\n        // Wait until data starts flowing to send a 200 OK,\n        // so errors don\'t trigger "headers already sent".\n        const start = Date.now();\n        stream.on("data", function handleData() {\n            console.log("Render Start: ", Date.now() - start);\n            stream.off("data", handleData);\n            response.useChunkedEncodingByDefault = true;\n            response.writeHead(200, {\n                "content-type": "text/html",\n                "content-transfer-encoding": "chunked",\n                "x-content-type-options": "nosniff",\n            });\n            response.write(BEFORE);\n            response.flushHeaders();\n        });\n        await new Promise((resolve, reject) => {\n            stream.on("error", (err) => {\n                stream.unpipe(response);\n                reject(err);\n            });\n            stream.on("end", () => {\n                console.log("Render End: ", Date.now() - start);\n                response.write("</div></body></html>");\n                response.end();\n                resolve();\n            });\n            stream.pipe(response, { end: false });\n        });\n    } catch (err) {\n        response.writeHead(500, {\n            "content-type": "text/pain",\n        });\n        response.end(String((err && err.stack) || err));\n        return;\n    }\n});\n')),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"progressive-hydration"},"Progressive Hydration"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Purpose: to partially hydrate the content on the client or to ",(0,s.kt)("strong",{parentName:"li"},"prioritize the content that needs to be hydrated"),"."),(0,s.kt)("li",{parentName:"ul"},"One popular way to achieve this is to wrap your component in the ",(0,s.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"},"Intersection Observer"))),(0,s.kt)("h3",{id:"pros"},"Pros"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Reduce first Time-To-Interact on the client-side."),(0,s.kt)("li",{parentName:"ol"},"Reduce first paint time on the client-side."),(0,s.kt)("li",{parentName:"ol"},"Serve content faster to the user without the user noticing any difference.")),(0,s.kt)("h3",{id:"example-progressive-hydration"},"Example: ",(0,s.kt)("a",{parentName:"h3",href:"https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples/tree/master/react-progressive-hydration"},"progressive-hydration")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples/blob/master/react-progressive-hydration/app/components/hydrator.js"},"react-progressive-hydration/app/components/hydrator.js"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'export class Hydrator extends React.Component {\n    shouldComponentUpdate() {\n        return false;\n    }\n\n    componentDidMount() {\n        new IntersectionObserver(async ([entry], obs) => {\n            if (!entry.isIntersecting) return;\n            obs.unobserve(this.root);\n\n            const { load, ...props } = this.props;\n            const Child = interopDefault(await load());\n            ReactDOM.hydrate(<Child {...props} />, this.root);\n        }).observe(this.root);\n    }\n\n    render() {\n        return (\n            <section\n                ref={(c) => (this.root = c)}\n                dangerouslySetInnerHTML={{ __html: "" }}\n                suppressHydrationWarning\n            />\n        );\n    }\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples/blob/master/react-progressive-hydration/app/components/app.js"},"react-progressive-hydration/app/components/app.js"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'export default function App() {\n    return (\n        <div id="app">\n            <Header />\n\n            <Intro />\n\n            {/* <Stream flush={flushing} /> */}\n            <Hydrator load={load} />\n        </div>\n    );\n}\n')),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"ndoejs-stream"},"Ndoe.js Stream"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://youtu.be/aTEDCotcn20"},"Stream Into the Future (NodeJS Streams)"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://www.esparkinfo.com/node-js-stream-in-detail.html"},"All You Need To Know About Node JS Stream In Detail")),(0,s.kt)("p",{parentName:"li"},"//TODO"))),(0,s.kt)("h2",{id:"reference"},"Reference"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://developers.google.com/web/updates/2019/02/rendering-on-the-web"},"Rendering on the Web")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.patterns.dev/posts/ssr/"},"Streaming Server-Side Rendering")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://youtu.be/UhdGiVy3_Nk"},"How Streaming Can Supercharge React - Sasha Aickin aka @xander76 at ReactEurope 2017")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://youtu.be/aTEDCotcn20"},"Stream Into the Future (NodeJS Streams)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.esparkinfo.com/node-js-stream-in-detail.html"},"All You Need To Know About Node JS Stream In Detail"))))}c.isMDXComponent=!0},148:function(e,t,r){"use strict";t.Z=r.p+"assets/images/client-side-rendering-flow-f18eb330a61206fba0cf64e76609baf5.png"},3235:function(e,t,r){"use strict";t.Z=r.p+"assets/images/rendering-methods-77ec40524b2ca90f99153bf4b0091aa7.png"},8334:function(e,t,r){"use strict";t.Z=r.p+"assets/images/rendering-0bda97cdcccfa31a712ec8507042b80d.png"},5270:function(e,t,r){"use strict";t.Z=r.p+"assets/images/server-side-rendering-flow-1efe74a767de7753d7f9d5adcb250519.png"},3130:function(e,t,r){"use strict";t.Z=r.p+"assets/images/ssr-vs-stream-dd0b4ea34be8ea655a20f237e7c9572e.png"}}]);