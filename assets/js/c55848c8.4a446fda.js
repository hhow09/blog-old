(self.webpackChunkhhow_09_github_io=self.webpackChunkhhow_09_github_io||[]).push([[4050],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return f}});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=i.createContext({}),p=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return i.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(t),f=r,m=c["".concat(s,".").concat(f)]||c[f]||d[f]||a;return t?i.createElement(m,o(o({ref:n},u),{},{components:t})):i.createElement(m,o({ref:n},u))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<a;p++)o[p]=t[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},8430:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},metadata:function(){return s},toc:function(){return p},default:function(){return d}});var i=t(2122),r=t(9756),a=(t(7294),t(3905)),o=["components"],l={},s={unversionedId:"algorithm/union-find",id:"algorithm/union-find",isDocsHomePage:!1,title:"Union Find",description:"Intro",source:"@site/docs/algorithm/1-union-find.md",sourceDirName:"algorithm",slug:"/algorithm/union-find",permalink:"/algorithm/union-find",editUrl:"https://github.com/hhow09/hhow09.github.io/blob/source/docs/algorithm/1-union-find.md",version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Index",permalink:"/"},next:{title:"Index",permalink:"/data-structure/index"}},p=[{value:"Intro",id:"intro",children:[]},{value:"Find(x)",id:"findx",children:[]},{value:"Union(A,B)",id:"unionab",children:[{value:"Union with rank",id:"union-with-rank",children:[]}]},{value:"Use Case",id:"use-case",children:[{value:"Detect cycle in undirected graph",id:"detect-cycle-in-undirected-graph",children:[]},{value:"Path Compression",id:"path-compression",children:[]}]},{value:"Performance",id:"performance",children:[]},{value:"DFS v.s. Union-Find",id:"dfs-vs-union-find",children:[]},{value:"Reference",id:"reference",children:[]}],u={toc:p};function d(e){var n=e.components,l=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"intro"},"Intro"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"disjoint-set")," is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) ",(0,a.kt)("inlineCode",{parentName:"li"},"subsets"),"."),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"union-find")," algorithm is an algorithm that performs two useful operations on such a data structure."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Union"),": Join two subsets into a single subset."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Find"),": Determine if two elements are in the same subset.")),(0,a.kt)("h2",{id:"findx"},"Find(x)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Purpose: return the root of ",(0,a.kt)("strong",{parentName:"li"},"the set that x is in")," also do ",(0,a.kt)("inlineCode",{parentName:"li"},"path compression")),(0,a.kt)("li",{parentName:"ul"},"path compression: start from x, find node's parent recursively until the root of the subset, the encountered nodes' parents will become root of the subset root."),(0,a.kt)("li",{parentName:"ul"},"find(A) == find(B) can check ",(0,a.kt)("strong",{parentName:"li"},"if vertex A and vertex B are under the same root or not"),".")),(0,a.kt)("p",null,(0,a.kt)("img",{src:t(7490).Z})),(0,a.kt)("h2",{id:"unionab"},"Union(A,B)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Purpose: set A and B to ",(0,a.kt)("strong",{parentName:"li"},"the root of A")," or ",(0,a.kt)("strong",{parentName:"li"},"root of B"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"can use ",(0,a.kt)("inlineCode",{parentName:"li"},"rank")," to determine"))),(0,a.kt)("li",{parentName:"ul"},"Steps",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"find(A) and Find B"))),(0,a.kt)("li",{parentName:"ul"},"return ",(0,a.kt)("inlineCode",{parentName:"li"},"False")," if ",(0,a.kt)("strong",{parentName:"li"},"already has same parent"),", no join needed"),(0,a.kt)("li",{parentName:"ul"},"return ",(0,a.kt)("inlineCode",{parentName:"li"},"True")," if join performed.")),(0,a.kt)("p",null,(0,a.kt)("img",{src:t(6444).Z})),(0,a.kt)("h3",{id:"union-with-rank"},"Union with rank"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Purpose: optimize the tree height"),(0,a.kt)("li",{parentName:"ul"},"set the vertex of larger rank as the parent of another one.")),(0,a.kt)("h4",{id:"2-is-better-than-1-for-smaller-tree-height"},"#2 is better than #1 for smaller tree height"),(0,a.kt)("p",null,(0,a.kt)("img",{src:t(5523).Z})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class UF:\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.ranks = [1] * n\n\n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n            # path compression\n        return self.parents[x]\n\n    def union(self, pos1, pos2):\n        parent1, parent2 = self.find(pos1), self.find(pos2)\n        if parent1 == parent2:\n            return False\n            # already has same parent, no join operation\n        if self.ranks[parent2] > self.ranks[parent1]:\n            self.parents[parent1] = parent2\n        elif self.ranks[parent1] > self.ranks[parent2]:\n            self.parents[parent2] = parent1\n        else:\n            self.parents[parent2] = parent1\n            self.ranks[parent1] += 1\n            #ranks of p1 plus for p2 joined p1\n        return True\n")),(0,a.kt)("h2",{id:"use-case"},"Use Case"),(0,a.kt)("h3",{id:"detect-cycle-in-undirected-graph"},"Detect cycle in undirected graph"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/detect-cycles-in-2d-grid/"},"1559. Detect Cycles in 2D Grid")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/redundant-connection/"},"684. Redundant Connection")),(0,a.kt)("li",{parentName:"ul"},"p.s. noted that for ",(0,a.kt)("inlineCode",{parentName:"li"},"directed graph")," which is not ",(0,a.kt)("inlineCode",{parentName:"li"},"disjoint-set")," so union-find is not feasible")),(0,a.kt)("h3",{id:"path-compression"},"Path Compression"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/evaluate-division/"},"399. Evaluate Division"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Union-Find")," + ",(0,a.kt)("inlineCode",{parentName:"li"},"Union by rank")," + ",(0,a.kt)("inlineCode",{parentName:"li"},"Path compression"))))),(0,a.kt)("h2",{id:"performance"},"Performance"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"union"),": worst case: ",(0,a.kt)("inlineCode",{parentName:"li"},"O(log N)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"find"),": worst case ",(0,a.kt)("inlineCode",{parentName:"li"},"O(log N)"))),(0,a.kt)("h2",{id:"dfs-vs-union-find"},"DFS v.s. Union-Find"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The union-find algorithm is best suited for situations where the ",(0,a.kt)("inlineCode",{parentName:"li"},"equivalence relationship is changing"),". i.e. if you have a graph with new edges being added, use ",(0,a.kt)("inlineCode",{parentName:"li"},"union-find"),"."),(0,a.kt)("li",{parentName:"ul"},"Given a fixed ",(0,a.kt)("inlineCode",{parentName:"li"},"undirected graph"),", you don't have the equivalence relationships changing at all i.e. the edges are all fixed. You can use both. However DFS is preferred in this situation for simpler and faster (",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)")," versus ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n alpha(n)"),"),")),(0,a.kt)("h2",{id:"reference"},"Reference"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://haogroot.com/2021/01/29/union_find-leetcode/?fbclid=IwAR218A84pYyJWxXOXyriq9ULjw8w2PvhQyjXYioKDJJkwvYVU9wIeSDzWeE"},"Union-Find \u2013 \u966a\u4f60\u5237\u984c")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"},"Graph: Intro(\u7c21\u4ecb)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/"},"Disjoint Set Union (Union Find)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"},"Graph: \u5229\u7528 DFS \u548c BFS \u5c0b\u627e Connected Component")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/union-find/"},"Disjoint Set (Or Union-Find) | Set 1 (Detect Cycle in an Undirected Graph)"))))}d.isMDXComponent=!0},7490:function(e,n,t){"use strict";n.Z=t.p+"assets/images/union-find-find-3af5ea775be2da343eb2e60a054052c3.gif"},5523:function(e,n,t){"use strict";n.Z=t.p+"assets/images/union-find-union-rank-b2bc077536d435f99446c1cf883c8555.gif"},6444:function(e,n,t){"use strict";n.Z=t.p+"assets/images/union-find-union-e1bd6f34615cbcb28b68741b272d8f4c.gif"}}]);