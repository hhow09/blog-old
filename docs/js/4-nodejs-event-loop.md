# Node.js Event Loop

## What is Event Loop

- Event loop is a programming construct or design pattern that waits for and dispatches events or messages in a program.
- Event Loop responsible for **scheduling code executions**, **collecting and processing events**, and **scheduling queued sub-tasks**.
- One of the important goal of event loop is provide **non-blocking I/O operations** for **single-thread** javascript engine.
- How `libuv` describe event loop
  > In event-driven programming, an application expresses interest in certain events and respond to them when they occur. The responsibility of gathering events from the operating system or monitoring other sources of events is handled by libuv, and the user can register callbacks to be invoked when an event occurs. The event-loop usually keeps running forever.
  - In pseudocode:
    ```
    e = get the next event
    if there is a callback associated with e:
    call the callback
    ```
- Event loop in `browser` or `Node.js` **is not part of the JS Engine (runtime)**.

## Concurrency Model and Event Loop

### in Browser(Chrome)

![Chrome Event Loop](/img/js/4-nodejs-event-loop/chrome-event-loop.png)

### in Node.js

![Node.js Event Loop](/img/js/4-nodejs-event-loop/nodejs-event-loop.png)

- While Nodejs uses the Google V8 as it's **runtime**, it does not used V8 to implement the **event loop**.
- Nodejs uses the **Libuv** library (written in C) to implement the event loop.

## Terms: of architecture & concept

### [libuv](https://github.com/libuv/libuv)

- libuv is a multi-platform support library with a focus on asynchronous I/O.
- It was primarily developed for use by Node.js
- libuv enforces an **asynchronous**, **event-driven** style of programming.
- Its core job is to provide an **event loop** and **callback based notifications of I/O** and other activities.
- libuv offers core utilities like **timers**, **non-blocking networking support**, **asynchronous file system access**, **child processes** and more.

- ref: [Basics of libuv](http://docs.libuv.org/en/v1.x/guide/basics.html)

### I/O

- Short for input/output, I/O refers primarily to the **program’s interaction with the system’s disk and network**.
- Examples of I/O operations include **reading/writing data from/to a disk** (`fs.readfileSync()`), **making HTTP requests**, and **talking to databases**.
- I/Os are very slow compared to **accessing RAM** or **doing work on the CPU**.

### Blocking v.s. Non-Blocking

- Blocking is when the execution of additional JavaScript in the Node.js process **must wait until a non-JavaScript operation completes**.
- Blocking happens because the event loop is unable to continue running JavaScript while a blocking operation is occurring.
- In Node.js, non-blocking primarily refers to **I/O operations**
- All of the I/O methods in the Node.js standard library provide async versions.
- Blocking methods execute **synchronously** and non-blocking methods execute **asynchronously**.

### Events and event-driven programming

- **Events** are actions generated by the user or the system, like a click, a completed file download, or a hardware or software error.
- **Event-driven programming** is a programming paradigm in which the **flow of the program is determined by events**.
- An event-driven program performs actions in response to events. When an event occurs it triggers a callback function.

### Thread Pool & Is Node.js Single Thread?

- in general code in Node.js is running with single thread developer cannot spawn a new thread (exception: [worker thread](https://nodejs.org/api/worker_threads.html#worker_threads_class_worker), and [child_process](https://nodejs.org/api/child_process.html#child_process_child_process))
- I/Os, file system operations are **multi-threaded** (not part of the JS code).
- libuv / Node.js provides a [threadpool](http://docs.libuv.org/en/v1.x/threadpool.html) of **default size 4**.
- New updates of Node.js offers [workerpool](https://www.npmjs.com/package/workerpool) to create threads easily.

```javascript
const crypto = require("crypto");
const start = Date.now();

//crypto.pbkdf2 is running in thread pool
function logHashTime() {
  crypto.pbkdf2("a", "b", 100000, 512, "sha512", () => {
    console.log("Hash: ", Date.now() - start);
  });
}
// default size of thread pool is 4
// first 4 will be execute in parallel (almost same time)
logHashTime();
logHashTime();
logHashTime();
logHashTime();

// 5th one will be execute later.
logHashTime();
```

- ref: [Node.js multithreading: What are Worker threads, and why do they matter?](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/)

---

## Terms of Tasks

:::info Priority of execution
Sync > Nanotask > Microtask > Task / Macrotask
:::

- Note: `nanotask` only exists in Node.js

### Task ( = `Macrotask`)

#### [Generic task sources](https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources)

- DOM manipulation/parsing
- User Interaction: keyboard or mouse input
- Network activity: `fetch`, `XMLHttpRequest`
- history traversal: `history.back()`
- Web APIs: `setTimeout`, `setInterval`, `setImmediate`(legacy), `requestAnimationFrame`, `I/O`, `UI rendering`

### Microtask

- `microtask` is a short function which **is executed after the function or program which created it exits and only if the JavaScript execution stack is empty, but before returning control to the event loop being used by the user agent to drive the script's execution environment**.
- microtasks can queue other microtasks, while there are microtasks in the microtask queue, they should all be run one by one until the microtask queue is empty.

#### Example of Microtask

- `Promise`, `Promise.then`
- `process.nextTick`
- `Object.observe`

### Tick

- a complete process of `one event loop` including:
  1. `dequeuing` of an event from the `event loop queue`
  2. the execution of said event.

---

## Event Loop in Node.js

> macrotask should be processed from the macrotask queue in one tick of the event loop. After this macrotask has finished, all other available microtasks should be processed within the same tick.

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

//TODO

---

## Reference

- [Using microtasks in JavaScript with queueMicrotask()](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide)
- [Node.js Under The Hood #3 - Deep Dive Into the Event Loop](https://dev.to/khaosdoctor/node-js-under-the-hood-3-deep-dive-into-the-event-loop-135d)
- [Node.js: Overview of Blocking vs Non-Blocking](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)
- [libuv: Basics of libuv](http://docs.libuv.org/en/v1.x/guide/basics.html)
- [Node.js: what it is, when and how to use it, and why you should](https://www.freecodecamp.org/news/node-js-what-when-where-why-how-ab8424886e2/)
- [MDN: Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#run-to-completion)

- [PJChenDer: [Note] Event loop, micro-task, macro-task, async JavaScript 筆記](https://pjchender.dev/javascript/note-event-loop-microtask/)
- [我知道你懂 Event Loop，但你了解到多深？](https://yeefun.github.io/event-loop-in-depth/?fbclid=IwAR0zHuodyFada1gfYL2P6CJjbHzxgX8KMAaUAlTsewERngKbswrf0guC-zU)
- [【筆記】到底 Event Loop 關我啥事？](https://medium.com/infinitegamer/why-event-loop-exist-e8ac9d287044)
