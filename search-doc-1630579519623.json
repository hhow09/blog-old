[{"title":"Hello","type":0,"sectionRef":"#","url":"blog/hello-world","content":"Welcome to this blog. This blog is created with Docusaurus 2 alpha. This is a test post. A whole bunch of other information.","keywords":""},{"title":"Hola","type":0,"sectionRef":"#","url":"blog/hola","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"blog/welcome","content":"Blog features are powered by the blog plugin. Simply add files to the blog directory. It supports tags as well! Delete the whole directory if you don't want the blog features. As simple as that!","keywords":""},{"title":"Union Find","type":0,"sectionRef":"#","url":"algorithm/union-find","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#intro","content":"A disjoint-set is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets.A union-find algorithm is an algorithm that performs two useful operations on such a data structure.Union: Join two subsets into a single subset.Find: Determine if two elements are in the same subset. "},{"title":"Find(x)","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#findx","content":"Purpose: return the root of the set that x is in also do path compressionpath compression: start from x, find node's parent recursively until the root of the subset, the encountered nodes' parents will become root of the subset root.find(A) == find(B) can check if vertex A and vertex B are under the same root or not.  "},{"title":"Union(A,B)","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#unionab","content":"Purpose: set A and B to the root of A or root of B can use rank to determine Steps find(A) and Find B return False if already has same parent, no join neededreturn True if join performed.  "},{"title":"Union with rank","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#union-with-rank","content":"Purpose: optimize the tree heightset the vertex of larger rank as the parent of another one. #2 is better than #1 for smaller tree height#  class UF: def __init__(self, n): self.parents = list(range(n)) self.ranks = [1] * n def find(self, x): if self.parents[x] != x: self.parents[x] = self.find(self.parents[x]) # path compression return self.parents[x] def union(self, pos1, pos2): parent1, parent2 = self.find(pos1), self.find(pos2) if parent1 == parent2: return False # already has same parent, no join operation if self.ranks[parent2] > self.ranks[parent1]: self.parents[parent1] = parent2 elif self.ranks[parent1] > self.ranks[parent2]: self.parents[parent2] = parent1 else: self.parents[parent2] = parent1 self.ranks[parent1] += 1 #ranks of p1 plus for p2 joined p1 return True Copy "},{"title":"Use Case","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#use-case","content":""},{"title":"find largest group","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#find-largest-group","content":"128. Longest Consecutive Sequence695. Max Area of Island "},{"title":"Detect cycle in undirected graph","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#detect-cycle-in-undirected-graph","content":"1559. Detect Cycles in 2D Grid684. Redundant Connectionp.s. noted that for directed graph which is not disjoint-set so union-find is not feasible "},{"title":"Path Compression","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#path-compression","content":"399. Evaluate Division Union-Find + Union by rank + Path compression "},{"title":"Performance","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#performance","content":"union: worst case: O(log N)find: worst case O(log N) "},{"title":"DFS v.s. Union-Find","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#dfs-vs-union-find","content":"The union-find algorithm is best suited for situations where the equivalence relationship is changing. i.e. if you have a graph with new edges being added, use union-find.Given a fixed undirected graph, you don't have the equivalence relationships changing at all i.e. the edges are all fixed. You can use both. However DFS is preferred in this situation for simpler and faster (O(n) versus O(n alpha(n)), "},{"title":"Reference","type":1,"pageTitle":"Union Find","url":"algorithm/union-find#reference","content":"Union-Find – 陪你刷題Graph: Intro(簡介)Disjoint Set Union (Union Find)Graph: 利用 DFS 和 BFS 尋找 Connected ComponentDisjoint Set (Or Union-Find) | Set 1 (Detect Cycle in an Undirected Graph) "},{"title":"698. Partition to K Equal Sum Subsets","type":0,"sectionRef":"#","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets","content":"","keywords":""},{"title":"Problem","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#problem","content":"Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4,3,2,3,5,2,1], k = 4 Output: true Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Copy Example 2: Input: nums = [1,2,3,4], k = 3 Output: false Copy "},{"title":"Solution 1 - Backtracking","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#solution-1---backtracking","content":"class Solution: def canPartitionKSubsets(self, nums: List[int], k: int) -> bool: allSum = sum(nums) if len(nums)<k or allSum %k !=0: return False nums.sort(reverse=True) # reverse for speed up parts = [allSum/k]*k def backtrack(parts, idx): if idx == len(nums): return sum(parts) == 0 for i in range(len(parts)): if parts[i]>= nums[idx]: parts[i] -= nums[idx] if backtrack(parts,idx+1): return True parts[i] += nums[idx] return backtrack(parts, 0) Copy "},{"title":"Solution 2 - Bit Mask","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#solution-2---bit-mask","content":"class Solution: def canPartitionKSubsets(self, nums: List[int], k: int) -> bool: if len(nums) < k or int(sum(nums)/k) != sum(nums)/k: return False N = len(nums) nums.sort(reverse=True) #[2]Sort the array in descending order, to improve run time. # print(\"nums\", nums) def dp(mask, cur, memo): # Top-down DP with memoization # print(\"cur\", cur) # print(\"mask in binary:\", format(mask, '0'+str(len(nums))+'b')) if mask == 0: return cur == 0 #[3] If mask == 0, all the elements have been used, and we need to see whether cur is equal to 0. elif cur == 0: return dp(mask, sum(nums)/k, memo) #[4] found an equal subset, but not some numbers haven't used. keep finding if (mask, cur) not in memo: res = False for bit in range(N): # 1 << bit: left shift, add bit num of 0 to the right of 1 # 1 << bit == pow(2, bit) if mask & (1 << bit): #[6] Check whether the number is unused. A set bit (1) means unused, 0 means used. if nums[bit] > cur: continue if dp(mask ^ (1 << bit), cur-nums[bit], memo): #[7] Use XOR to mark set bit as used (change from 1 to 0) res = True break memo[(mask, cur)] = res return memo[(mask, cur)] return dp(pow(2,N)-1, sum(nums)/k, dict()) #[8] Initialize mask as 11111...., N set bits. Copy "},{"title":"Explanation","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#explanation","content":"for sorted nums [1, 3 ,7, 10], bitmask 0000 means subset []bitmask 0110 means subset [3,7]bitmask 1111 means subset [1,3,7,10] start with mask 1111, means all unused 1 << bit == pow(2,bit) use AND gate (&) of mask and (1 << bit) to check if specific nums[bit] is unused. use XOR gate (^) of mask and (1 << bit) to mark nums[bit] as used. "},{"title":"Reference","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#reference","content":"https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/867956/Python3-Two-solutions-DP-with-Bit-mask(48ms)-DFS%2Bbacktracking-with-detailed-explanations "},{"title":"Index","type":0,"sectionRef":"#","url":"data-structure/index","content":"","keywords":""},{"title":"Basic Data Structures","type":1,"pageTitle":"Index","url":"data-structure/index#basic-data-structures","content":""},{"title":"data structures in practice","type":1,"pageTitle":"Index","url":"data-structure/index#data-structures-in-practice","content":""},{"title":"B-Tree","type":0,"sectionRef":"#","url":"data-structure/b-tree","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#intro","content":"B-tree is a self-balancing tree data structureB-tree maintains sorted data and allows searches, sequential access, insertions, and deletions in O(log(n)).B-tree is well suited for storage systems that read and write relatively large blocks of data, such as disks (slower & larger capacity). The need for B-tree arose with the rise in the need for lesser time in accessing the physical storage media like a hard disk.Comparing with other binary search tree, avl tree, red-black tree, B-tree can store many keys in a single node and can have multiple child nodes which decreases the height significantly then allowing faster disk accesses.It is commonly used in databases and file systems. "},{"title":"Definition","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#definition","content":"a B-tree of order m is a tree which satisfies the following properties: "},{"title":"A B-tree of order m=5","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#a-b-tree-of-order-m5","content":" order m (also known as branching factor): each nonleaf node contains minimum number (ceiling) [m-1]/2 of keysmximum number m-1 of keysnumber_of_keys + 1 of child nodes All leaves are at the same level.root may contain minimum 1 key.Number of children of a node is equal to the number_of_keys + 1.All keys of a node are sorted in increasing order.The child between two keys k1 and k2 contains all keys in the range from k1 to k2.B-Tree grows and shrinks from the root which is unlike Binary Search Tree. Binary Search Trees grow downward and also shrink from downward.Like other balanced Binary Search Trees, time complexity to search, insert and delete is O(log n). "},{"title":"B-tree Insertion","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#b-tree-insertion","content":"Insertion of a node in B-Tree happens only at Leaf Node. "},{"title":"Steps","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#steps","content":"Find a leaf node for a new item. Start from the root.If the root is an internal node, look at each element from the beginning and stop when an element > X is found.Eventually traversing pointers will come to a leaf node. At the leaf node If there is room in the leaf If leaf is full, split it into 2 leaves, and copy and insert the middle element into the (internal) parent node If leaf's parent is full, split the parent into 2 internal nodes, and copy and insert the middle element into its parent node. "},{"title":"B-Tree Deletion","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#b-tree-deletion","content":""},{"title":"Case 1 : Delete a leaf node","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#case-1--delete-a-leaf-node","content":"Case 1-1: if sufficient child node# Implementation: Directly Delete  Case 1-2: insufficient child node# Violation of: nonleaf node should contains number_of_keys + 1 of child nodesImplementation: borrow a key from its immediate neighboring sibling node in the order of left to right.  Case 1-3: insufficient child node & all sibling has minimum child node# Implementation: merge the node with either the left sibling node or the right sibling node.  "},{"title":"Case 2 : Delete a nonleaf node","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#case-2--delete-a-nonleaf-node","content":"Case 2-1: if left child or right child has more than minimum keys# Implementation: The deleted node is replaced by an inorder predecessor if the left or child child has more than the minimum number of keys.  Case 2-2: if left child and right child has only minimum keys# Implementation: merge the left and the right children if left child and right child has only minimum keys.  Case 2-3: deletion of the key leads to a fewer number of keys in the node# Implementation: height of the tree shrinks, merging the children.  "},{"title":"Optimization of B-tree","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#optimization-of-b-tree","content":"size saving: we don't have to store all the key.Range query: store in to near segments helps range query. "},{"title":"B-Tree v.s. LSM-Trees","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#b-tree-vs-lsm-trees","content":"//TODO "},{"title":"Reference","type":1,"pageTitle":"B-Tree","url":"data-structure/b-tree#reference","content":"417 lecture note #3 B-Treeprogramiz: Deletion from a B-tree學習手記：2018 清華大學 DB/AI Bootcamp — II — B-Tree IndexingDesigning Data-Intensive Applications: CHAPTER 3 Storage and Retrieval "},{"title":"Frontend Test","type":0,"sectionRef":"#","url":"fe-test/index","content":"","keywords":""},{"title":"Types of Test","type":1,"pageTitle":"Frontend Test","url":"fe-test/index#types-of-test","content":" End to End test A helper robot that behaves like a user to click around the app and verify that it functions correctly. Sometimes called functional testing or e2e. Framework: cypress Integration test It validate how multiple units of your application work together but are more lightweight than E2E tests. Jest uses jsdom under the hood to emulate common browser APIs with less overhead than automationJest has robust mocking tools to stub out external API calls. Unit test Verify that individual, isolated parts work as expected.They are easy to write, but can miss the big picture.Framework: Jest Static test Catch typos and type errors as you write the code. Framework: ESLint, Typescript  "},{"title":"Jest: Coverage Report","type":1,"pageTitle":"Frontend Test","url":"fe-test/index#jest-coverage-report","content":" Statements represent instructions that have been executed at least once during the unit tests. Branches represent if statements which conditions have been fulfilled at least once during the unit tests.Functions represent functions that have been called at least once during the unit tests.Lines represent code lines that have executed at least once during the unit tests. "},{"title":"Jest: Set up Guide","type":1,"pageTitle":"Frontend Test","url":"fe-test/index#jest-set-up-guide","content":"Testing React AppsSetting Up Testing Library with NextJSReact: Testing Recipes "},{"title":"Reference","type":1,"pageTitle":"Frontend Test","url":"fe-test/index#reference","content":"Static vs Unit vs Integration vs E2E Testing for Frontend AppsSetting Up Testing Library with NextJSCombining Storybook, Cypress and Jest Code Coverage "},{"title":"Skip List","type":0,"sectionRef":"#","url":"data-structure/skip-list","content":"","keywords":""},{"title":"What is Skip List?","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#what-is-skip-list","content":"A skip list is a probabilistic data structure.A skip list takes O(log(n)) time to add, erase and search, which is not possible in array or linked listA skip list is indexable to make random access take O(log n) time.A skip list has the same function and performance comparing with treap and red-black tree.That the skip list can be interpreted as a type of randomly balanced tree "},{"title":"Data Structure","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#data-structure","content":" a node: contains value valheight ha list of pointers node[] next from level 0 to level h.The next[i] representing the pointer of level i which points to the next node of same level i. listHeight: The height of a skip list is the height of its tallest node.MaxHeight: A constant that limit the height of skip list.sentinel: the dummy head node of list of every level. usually initialize with value of Number.MIN_SAFE_INTEGER, h of MaxHeight-1Every search starts from sentinel. probability p: If a node contains level from 0 to i, the probability that it has i+1 level. "},{"title":"Search","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#search","content":""},{"title":"The search path for the node containing 4.","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#the-search-path-for-the-node-containing-4","content":" The higher the level, the sparser the list.Search starts from high level to low level.Some nodes are skipped during search, resulting in the similarity to binary search. "},{"title":"Search Algorithm","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#search-algorithm","content":" // find the predecessor private Node findPred(int num) { Node cur = sentinel; for (int r = topLevel; r >= 0; r--) { while (cur.next[r] != null && cur.next[r].val < num) cur = cur.next[r]; stack[r] = cur; } return cur; } public boolean search(int target) { Node pred = findPred(target); return pred.next[0] != null && pred.next[0].val == target; } Copy "},{"title":"Add","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#add","content":""},{"title":"Adding an element to a skip list","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#adding-an-element-to-a-skip-list","content":"  private int pickHeight() { return Math.floor(Math.random() * MAX_HEIGHT); } public void add(int num) { Node pred = findPred(num); if (pred.next[0] != null && pred.next[0].val == num) { pred.next[0].count++; return; } Node newNode = new Node(num, pickHeight()); while (topLevel < newNode.h) stack[++topLevel] = sentinel; for (int i = 0; i <= newNode.h; i++) { //connect all prev and next nodes of level 0 - newNode.h newNode.next[i] = stack[i].next[i]; stack[i].next[i] = newNode; } } Copy "},{"title":"Random Access O(log(n))","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#random-access-ologn","content":" 1 10 o---> o---------------------------------------------------------> o Top level 1 3 2 5 o---> o---------------> o---------> o---------------------------> o Level 3 1 2 1 2 3 2 o---> o---------> o---> o---------> o---------------> o---------> o Level 2 1 1 1 1 1 1 1 1 1 1 1 o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o Bottom level Head 1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th NIL Node Node Node Node Node Node Node Node Node Node Copy we can store the length of list (bottom level)For example, to find 5th node, the path will be. Traverse from top level list, but moving to next node costs 10 more steps, which is too much.Therefore, drop one level to level 3 and move next to 4th node.drop one level to level 2.drop one level to bottom level.move next to 5th node. "},{"title":"Performance","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#performance","content":"A skip list of n nodes and probability p.Node number of level i is n * p^(i-1) first level: nsecond level: n * pthird level: n * p^2 average search length is the order of log(n) "},{"title":"Indexable skiplist","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#indexable-skiplist","content":""},{"title":"Balanced Tree v.s. Skip List","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#balanced-tree-vs-skip-list","content":"Concurrent programming when the tree is modified it often needs to re-balance, affecting large portions of the tree. Then it will require a mutex lock on many of the tree nodes.Inserting a node into a skip list is far more localized, only nodes directly linked to the affected node need to be locked. Skip List vs. Binary Search Tree "},{"title":"Application","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#application","content":""},{"title":"Skip list in Redis","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#skip-list-in-redis","content":"Redis 内部数据结构详解(6)——skiplist "},{"title":"Skip list in Lucene","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#skip-list-in-lucene","content":"How does lucene index documents?In a nutshell, Lucene builds an inverted index using Skip-Lists on disk, and then loads a mapping for the indexed terms into memory using a Finite State Transducer (FST). "},{"title":"Reference","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#reference","content":"Leetcode 1206. Design SkiplistOpen Data Structure 4 SkiplistsRedis 内部数据结构详解(6)——skiplist "},{"title":"Jest: Test with Mock Functions","type":0,"sectionRef":"#","url":"fe-test/jest-test-with-mock-functions","content":"","keywords":""},{"title":"Mock Hooks","type":1,"pageTitle":"Jest: Test with Mock Functions","url":"fe-test/jest-test-with-mock-functions#mock-hooks","content":"const useRouter = jest.spyOn(require(\"next/router\"), \"useRouter\"); describe(\"Navbar Testing\", () => { test(\"Navbar content exists\", () => { useRouter.mockImplementationOnce(() => ({ pathname: \"/\", })); const { container } = render(<Navbar />); expect(container).toMatchSnapshot(); }); }); Copy "},{"title":"Reference","type":1,"pageTitle":"Jest: Test with Mock Functions","url":"fe-test/jest-test-with-mock-functions#reference","content":"Jest: Mock Functions "},{"title":"Closure","type":0,"sectionRef":"#","url":"js/js-closure","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Closure","url":"js/js-closure#intro","content":"網路上許多閉包的教學都沒有直接明確的定義，只知道 use case 和長什麼樣子。直到看到這篇[教學] JavaScript Closure (閉包)、函式與語彙環境，搭配You-Dont-Know-JS一起讀才豁然開朗。 "},{"title":"Definition","type":1,"pageTitle":"Closure","url":"js/js-closure#definition","content":"MDN/Closures的定義 A closure is the combination of a function and the Lexical Environment within which that function was declared. JavaScript 中的 Closure 是函式以及其語彙環境 (Lexical Environment) 的組合。Closure 是一個函式能夠存取自己被宣告時的環境中的變數。如果不處理函數，則 Closure 不適用。一個 Object 不能有 Closure ，一個 Clas 也不能有閉包。 Lexical Environment 詞法作用域是一套關於引擎如何尋找變量以及會在何處找到變量的規則。詞法作用域最重要的特徵是它的定義過程發生在代碼的書寫階段。 "},{"title":"Example","type":1,"pageTitle":"Closure","url":"js/js-closure#example","content":"function makeFunc() { // 1 let name = \"John\"; // 2 function displayName() { // 3 console.log(name); } return displayName; // 4 } let func1 = makeFunc(); // 5 func1(); Copy "},{"title":"特性","type":1,"pageTitle":"Closure","url":"js/js-closure#特性","content":""},{"title":"閉包 + 函式可被回傳","type":1,"pageTitle":"Closure","url":"js/js-closure#閉包--函式可被回傳","content":"結果: 函式可以在作用域以外之處執行 "},{"title":"閉包 + 函式可被回傳 + Lexical Environment","type":1,"pageTitle":"Closure","url":"js/js-closure#閉包--函式可被回傳--lexical-environment","content":"原因: 在 JavaScript 中，即使在外層區塊(makeFunc)已經回傳的狀況下，由於內部作用域(displayName)依然存在，只要內層區塊還保留著一份參考，那麽外層區塊的環境不會隨著回傳而被垃圾回收機制回收，我們依然可以存取外層環境中的變數(//5)。結果: 閉包 (closure) 可以「保留」函數宣告的環境。 "},{"title":"一定要return?","type":1,"pageTitle":"Closure","url":"js/js-closure#一定要return","content":"即使 displayName 只有被執行沒有 return，也可以稱作閉包。但如果不 return，就無法使用這個閉包。return 目的只是要讓作用域外別的函式可以訪問到這個 displayName 函式，因此 return 與否，與是否是閉包無關。 "},{"title":"Reference","type":1,"pageTitle":"Closure","url":"js/js-closure#reference","content":"You-Dont-Know-JSMDN/Closures[教學] JavaScript Closure (閉包)、函式與語彙環境所有的函式都是閉包：談 JS 中的作用域與 ClosureDay6 [JavaScript 基礎] 垃圾回收機制 "},{"title":"Functional Programming","type":0,"sectionRef":"#","url":"js/js-fp","content":"","keywords":""},{"title":"Concepts","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#concepts","content":""},{"title":"Side Effect","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#side-effect","content":"函數影響或修改到其他作用域的值，稱作 Side Effectpure function 沒有 Side Effect "},{"title":"Referential transparency","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#referential-transparency","content":"pure function 的必要條件，也就是所有pure function必須是 referentially transparent 的。給定一個 function 和一個 input 值，始終會收到相同的 out。 也就是說函數中沒有使用外部狀態。 "},{"title":"Immutability","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#immutability","content":"在 Javascript 中，objct 是通過 pass by reference 的，因此我們可以直接修改(mutate) Object。在 Functional Programming 中每當我們處理一個 Obect 時，我們都會回傳 new Object 而不是修改/污染原 Object，即 Immutability。 "},{"title":"Declarative 宣告式 vs. Imperative 命令式","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#declarative-宣告式-vs-imperative-命令式","content":"Imperative# 通常用在 OOP著重在 HOW，具體表達程式碼該做什麼才能達到目標，程式一步一步按著順序照著你給他指示執行。比較常運用 Statement ，也就是 if , while , for , switch 等。 Declarative# 通常用在 FP著重在該做什麼 WHAT ，並採取抽象化流程。比較常運用表達式 expression，表達式特色是單純運算並一定會有返回值。 "},{"title":"Point free function","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#point-free-function","content":"通過刪除不必要的參數 mapping 來提供整潔性。 "},{"title":"Compose v.s. Pipe","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#compose-vs-pipe","content":"compose(fn2, fn1) = fn2( fn1() ): 從右到左pipe(fn2, fn1) equals to fn1( fn2() ): 從左到右 const pipe = reverseArgs(compose); Copy  "},{"title":"Functional Programming 的基本技巧","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#functional-programming-的基本技巧","content":""},{"title":"Closure","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#closure","content":"JavaScript 中的 Closure 是函式以及其語彙環境 (Lexical Environment) 的組合。Closure 是一個函式能夠存取自己被宣告時的環境中的變數。如果不處理函數，則 Closure 不適用。一個 Object 不能有 Closure ，一個 Class 也不能有閉包。Closures 在 runtime 時 function 建立後才誕生。 "},{"title":"Curry","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#curry","content":"Curry/Currying 是一種將帶有多個參數的 function 轉換為一系列一元函數的技術，每個一元函數都只有一個參數。Currying 和 partial application相關但不相同。 Example: Hard Coded Currying# const add3Args = (a, b, c) => a + b + c; const addCurried = (a) => (b) => (c) => a + b + c; add(2, 3, 6); //11 addCurried(2)(3)(6); //11 Copy "},{"title":"Composition","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#composition","content":"Curried function 非常適合 function 組合。 function 的組合：每個 function 都接收上一個 function 的返回值。 // in algrebra f . g . h = f(g(h(x))) Copy //in Javascript const compose = (...fns) => (x) => fns.reduceRight((y, f) => f(y), x); Copy  "},{"title":"Interview Problem: Implement Currying","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#interview-problem-implement-currying","content":"const add3Args = (a, b, c) => a + b + c; // args長度固定 const add = (...args) => args.reduce((result, arg) => result + arg); // args 長度不固定 const curry = (fn, arity = fn.length) => (function nextCurried(prevArgs) { return (nextArg) => { const args = [...prevArgs, nextArg]; if (args.length >= arity) { return fn(...args); } else { return nextCurried(args); } }; })([]); curry(add3Args)(1)(3)(7); // 11 curry(add, 3)(1)(3)(7); // 11 Copy arity: 預計傳入參數數量，如果長度不固定需要 specify。 初始 [] 做為 prevArgs，收集已傳入的參數。 接每一次傳入的實際參數 nextArg 與 prevArgs 合併成 args。 當 args 長度小於 arity 時，return nextCurried(prevArgs)，prevArgs 也就是下一輪的 prevArgs。 當 args 長度大於 arity 時，代表已收集到足夠的 args，就利用這些 args，呼叫原函數 fn。 reference: 第 15 题：实现 add(1)(2)(3) #21  "},{"title":"Interview Problem: Sum of Arguments","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#interview-problem-sum-of-arguments","content":""},{"title":"Problem","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#problem","content":"Create a sum function that will calculate the sum of arguments. if there aren’t any arguments, return the result, if there are any arguments, return a function that can be used for the next calculation. Example sum() // return 0; sum(1)() // return 1; sum(1, 1, 1)() // return 3; sum(1)(1)(1)() // return 3; sum(1)(1, 1, 1, 1)(1)() // return 6 sum(1) // return a function sum(1)…….(1, 1, 1,…1) // return a function Copy "},{"title":"Solution","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#solution","content":"function sum(...args) { let sum = 0; sum += args.reduce((res, el) => res + el, 0); function f(...fArgs) { if (fArgs.length === 0) return sum; sum += fArgs.reduce((res, el) => res + el, 0); return (...newArgs) => f(...newArgs); } return (...newArgs) => f(...newArgs); } Copy  "},{"title":"Javascript Functional Libraries","type":1,"pageTitle":"Functional Programming","url":"js/js-fp#javascript-functional-libraries","content":"LodashUnderscore.jslazyJSRamda "},{"title":"Immutability","type":0,"sectionRef":"#","url":"js/js-immutability","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Immutability","url":"js/js-immutability#introduction","content":"Javascript reference data type Object has mutable characteristics. The benefit of mutability is memory-saving. However in frontend scenario, the disadvantage of side effect often outweigh the advantage.Without immutability, you might have to pass an object around between different scopes, and you do not know beforehand if and when the object will be changed. The code becomes unpredictable and is difficult to debug.Immutability in Javascript means we cannot update variable by reference. Whenever we want to update a variable, we create a new reference.  "},{"title":"Benefits of Immutability","type":1,"pageTitle":"Immutability","url":"js/js-immutability#benefits-of-immutability","content":"PredictabilityMutation hides change, which create (unexpected) side effects, which can cause nasty bugs. When you enforce immutability you can keep your application architecture and mental model simple. Mutation TrackingImmutability allows you to optimize your application by making use of reference and value equality. This makes it really easy to see if anything has changed. Boost performance (indirectly)When facing mutable data structure, we want to know if object change by iterating through all properties. In contrast, facing immutable data structure, we only have to check equality of reference. Reduce the need of lock when concurrent programming (not completely) The core problem of multi thread programming is race condition. We need to ensure atomic characteristic inside critical operation by some methods such as lock. "},{"title":"How immutability boosts React performance","type":1,"pageTitle":"Immutability","url":"js/js-immutability#how-immutability-boosts-react-performance","content":""},{"title":"Background","type":1,"pageTitle":"Immutability","url":"js/js-immutability#background","content":"React maintains an internal representation of the UI, the so-called virtual DOM.When a property or the state of a component changes, this virtual DOM is updated to reflect those changes. Manipulating the virtual DOM is easier and faster because nothing is changed in the UI.Then, React compares the virtual DOM with a version before the update in order to know what changed. This is the reconciliation process. "},{"title":"When we want to avoid unnecessary re-render","type":1,"pageTitle":"Immutability","url":"js/js-immutability#when-we-want-to-avoid-unnecessary-re-render","content":"React in default re-render components whenever state or props change.Sometimes knowing what changes could be very difficult when props is deep nested object.If the props are guaranteed the immutability characteristic, we can simply know wether the props change by performing simple equality check without dive into nested object and compare values respectively. class MyComponent extends Component { // ... shouldComponentUpdate(nextProps, nextState) { if (this.props !== nextProps) { return true; } return false; } // ... } Copy  "},{"title":"How to implement immutability?","type":1,"pageTitle":"Immutability","url":"js/js-immutability#how-to-implement-immutability","content":"To clarify before we start, when talking about create a new reference when updating a variable, we do not refer to performs deep copy operation JSON.parse(JSON.stringify(obj)) because it simply recreate all properties even of those not changed. This actually hurt performance. "},{"title":"Persistent data structures","type":1,"pageTitle":"Immutability","url":"js/js-immutability#persistent-data-structures","content":"Persistent data structures enforces a constraint that all operations will return a newer version of that data structure and keep the original structure intact,e.g. reusing existing nodes as much as possible. "},{"title":"Spread Operator (ES6) (without Library)","type":1,"pageTitle":"Immutability","url":"js/js-immutability#spread-operator-es6-without-library","content":"When perform state update in React, we often need to do operations such as modify a properties in Object, append element to array, andinsert array. Thanks to Spread Operator in Javascript ES6, we can only update the specific property and keep other references intact. Rect officially recommend this way to do state update, The Power Of Not Mutating Data. modify a properties in Object const [myData, setMyData] = useState({ myName: \"Howard\", myPhoneNum: \"0912345678\" }); setMyData((prevState) => { return { ...prevState, myName: \"Cool Howard\" }; }); // { myName: \"Cool Howard\", myPhoneNum: \"0912345678\" } Copy append element to array const [sentence, setSentence] = useState([\"You\", \"are\", \"an\", \"awesome\"]); setSentence((prevState) => [...prevState, \"programmer\"]); // [\"You\", \"are\", \"an\",\"awesome\", \"programmer\"] Copy insert array const [sentence, setSentence] = useState([\"You\", \"are\", \"awesome\", \"programmer\"]); setSentence((prevState) => [...prevState.slice(0, 2), \"an\", ...prevState.slice(2)]); // [\"You\", \"are\", \"an\",\"awesome\", \"programmer\"] Copy  "},{"title":"Immutable.js library","type":1,"pageTitle":"Immutability","url":"js/js-immutability#immutablejs-library","content":"Nowadays, Immutable.js is the most famous library. It implements fully persistent data structures including: List, Stack, Map, OrderedMap, Set, OrderedSet and Record.It provides mutative API to update data in an efficient and immutable way. "},{"title":"Behind the scene","type":1,"pageTitle":"Immutability","url":"js/js-immutability#behind-the-scene","content":"How Immutable Data Structures (E.g. Immutable.js) are OptimizedImmutable.js, persistent data structures and structural sharing These articles illustrated how to implement object into immutable as well as persistent data structure using Trie "},{"title":"When to use immutable library?","type":1,"pageTitle":"Immutability","url":"js/js-immutability#when-to-use-immutable-library","content":"Please don’t take this article to mean “you should always use Immutable.js.” No, I’m just trying to highlight its benefits in this article and explain why it’s recommended a lot. There are still drawbacks using immutable library: We will couple the most basic data structure with a library.The size of package increase.When frequently communicating with server, we will have to convert the data structure between library and native Javascript.  "},{"title":"Reference","type":1,"pageTitle":"Immutability","url":"js/js-immutability#reference","content":"Immutable Data Structures and JavaScriptImmutability in React: There’s nothing wrong with mutating objectsImmutable.jsImmutable 详解及 React 中实践 #3Immutable.js, persistent data structures and structural sharingPersistent Data Structure "},{"title":"Javascript Dev Notes","type":0,"sectionRef":"#","url":"js/js-dev-note","content":"","keywords":""},{"title":"1. Trace Call Stack","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#1-trace-call-stack","content":"this is useful especially in developing / debugging multi-repo console.log((new Error()).stack.split(\"\\n\"))arguments.callee.caller.toString() (not work in strict mode) "},{"title":"2. console.log an Object is pass by reference","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#2-consolelog-an-object-is-pass-by-reference","content":"object is pass by referenceobject may have changed when log shows Don't use console.log(obj), use console.log(JSON.parse(JSON.stringify(obj))). This way you are sure you are seeing the value of obj at the moment you log it. Otherwise, many browsers provide a live view that constantly updates as values change. This may not be what you want. reference: Logging objects  "},{"title":"3. Initializing 2D array with Array.fill","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#3-initializing-2d-array-with-arrayfill","content":"if filled value is Object, Array or function, e.g. pass by reference, they will reference to the same object. const list = new Array(3).fill(new Array(4).fill(1)); const list2 = new Array(3).fill(null).map(() => new Array(4).fill(1)); list[1][2] = 2; list2[1][2] = 2; console.log(list); // false //[ // [ 1, 1, 2, 1 ], // [ 1, 1, 2, 1 ], // [ 1, 1, 2, 1 ] //] console.log(list2); // correct //[ // [ 1, 1, 1, 1 ], // [ 1, 1, 2, 1 ], // [ 1, 1, 1, 1 ] //] Copy list1 filled each row with same reference of new Array(4).fill(1). if modified list[1][2], every row of index 2 will also be modified.list two is creating 2D array of each different row.  "},{"title":"4. Deep Copy v.s. Shallow Copy","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#4-deep-copy-vs-shallow-copy","content":"Shallow Copy# Array.prototype.slice()Object.assign({}, obj);Spread Syntax: A2 = {...A1} Deep Copy# JSON.parse(JSON.stringify(object)) If you do not use circular reference, Dates, functions, undefined, Infinity, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, it is a very simple one liner to deep clone an object. with library: lodash - cloneDeep  "},{"title":"5. Manipulating with floating-point number","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#5-manipulating-with-floating-point-number","content":"JavaScript has a single and unpredictable number type, 64-bit floating point. 0.1 + 0.2 === 0.3; // false function numbersCloseEnoughToEqual(n1, n2) { return Math.abs(n1 - n2) < Number.EPSILON; } numbersCloseEnoughToEqual(0.1 + 0.2, 0.3); Copy  "},{"title":"6. Function arguments are pass-by-reference","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#6-function-arguments-are-pass-by-reference","content":"function foo(x) { x.push(4); x; // [1,2,3,4] x = [4, 5, 6]; //re-assign, reference changed x.push(7); x; // [4,5,6,7] } var a = [1, 2, 3]; foo(a); a; // [1,2,3,4] Copy  "},{"title":"7. Key order of Object.keys(obj)?","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#7-key-order-of-objectkeysobj","content":"ES5# depend on browserref: ECMA 5.0 Object.keys (O) For each own enumerable property of O whose name String is P Call the [[DefineOwnProperty]] internal method of array with arguments ToString(index), the PropertyDescriptor {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. Increment index by 1. If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration order must be used in step 5 of this algorithm. ES6:# depend on OwnPropertyKeys methodReflect.ownKeys also depend on OwnPropertyKeysOrder integers: in numeric orderstrings: in chronological orderSymbols: in chronological order ref: ECMA 6.0 Object.keys ( O ) const obj = { 2: \"integer: 2\", foo: \"string: foo\", \"01\": \"string: 01\", 1: \"integer: 1\", [Symbol(\"first\")]: \"symbol: first\", }; obj[\"0\"] = \"integer: 0\"; obj[Symbol(\"last\")] = \"symbol: last\"; obj[\"veryLast\"] = \"string: very last\"; console.log(Reflect.ownKeys(obj)); // [ \"0\", \"1\", \"2\", \"foo\", \"01\", \"veryLast\", Symbol(first), Symbol(last) ] Copy  "},{"title":"8. Remove Duplicate Element in Array","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#8-remove-duplicate-element-in-array","content":"const chars = [\"A\", \"B\", \"A\", \"C\", \"B\"]; const uniqueChars = chars.filter((c, index) => chars.indexOf(c) === index); //[ 'A', 'B', 'C' ] Copy "},{"title":"9.DOM Element","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#9dom-element","content":""},{"title":"DOM Element is a special object","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#dom-element-is-a-special-object","content":"var a = document.createElement(\"div\"); typeof a; // \"object\" Object.prototype.toString.call(a); // \"[object HTMLDivElement]\" a.tagName; // \"DIV\" Copy Cannot call some built-in methods such as toString()Cannot be overwritten / override some properties such as this "},{"title":"DOM Element will produce global variable","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#dom-element-will-produce-global-variable","content":"be careful for duplicate naming. <div id=\"foo\"></div> Copy console.log(foo); // HTML Element Copy "},{"title":"10. symlink","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#10-symlink","content":"especially useful when developing multi-repo "},{"title":"Example","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#example","content":"repo A use repo B as dependency root-folder ├── repo-A | └──node_modules | └──repo-B ├── repo-B Copy in repo-B npm run build, assume output is /distin repo-A/node_modules rm -rf repo-Bln -s root-folder/repo-B/dist ./repo-B to create Symlinkls -al to check, we should see Symlink repo-B -> /root-folder/repo-B/dist By this way we can see effect on repo-A after modifying repo-B and rebuild simply on local.For better dev experience, use webpack watch to auto rebuild on change. "},{"title":"11. using await inside setInterval is pointless","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#11-using-await-inside-setinterval-is-pointless","content":"since interval won't wait for await async function getData (){ return fetch(\"url...\") } const timer = setInterval( await getData(); ,1000) Copy can change into async function getData() { return fetch(\"https://google.com\"); } async function sleep(ms) { return await new Promise((resolve) => setTimeout(resolve, ms)); } function periodicGetData() { return new Promise(async (resolve, reject) => { if (some_condition) { resolve(); } const res = await getData(); if (res instanceof Error) { reject(res); } console.log(\"res\", res); await sleep(1000); return periodicGetData(); }); } periodicGetData(); Copy  "},{"title":"Reference","type":1,"pageTitle":"Javascript Dev Notes","url":"js/js-dev-note#reference","content":"You Don't Know JSProperty order is predictable in JavaScript objects since ES2015 "},{"title":"Concurrency vs. Parallelism v.s. Coroutine","type":0,"sectionRef":"#","url":"programming/concurrent-vs-parallelism","content":"","keywords":""},{"title":"Intro: The Free Lunch Is Over","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#intro-the-free-lunch-is-over","content":"The major processor manufacturers and architectures, from Intel and AMD to Sparc and PowerPC, have run out of room with most of their traditional approaches to boosting CPU performance. Instead of driving clock speeds and straight-line instruction throughput ever higher, they are instead turning en masse to hyperthreading and multicore architectures. more: The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software  "},{"title":"Multi Threading","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#multi-threading","content":"CPU will manage/scheduling its own threads.Multi-threading is the prerequisite of multi-processing  "},{"title":"Benefits of Multi Threading","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#benefits-of-multi-threading","content":"Responsiveness# Multi-threading in an interactive application may allow a program to continue running even if a part (thread) of it is blocked or is performing a lengthy operation, thereby increasing responsiveness to the user. Resource Sharing# (Compared to)Processes may share resources only through techniques such as Message Passing and Shared Memory.However, threads share the memory and the resources of the process to which they belong by default. Economy# Allocating memory and resources for process creation is a costly job in terms of time and space.Threads share memory with the process it belongs, it is more economical to create and context switch threads. Scalability# If there is only one thread then it is not possible to divide the processes into smaller tasks for parallelism.Single threaded process can run only on one processor regardless of how many processors are available.  "},{"title":"Concurrency & Parallelism","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#concurrency--parallelism","content":"Concurrency is composition of independently executing things (typically, functions). We often use the word process to refer to such running thing, and we don't mean unix process, but rather a process in the abstract, general sense. Parallelism is simultaneous execution of multiple things. Those things might or might not be related to each other. Concurrency is about dealing with a lot of things at once. Parallelism is about doing a lot of things at once.The ideas are, obviously, related, but one is inherently associated with structure, the other is associated with execution. Concurrency is structuring things in a way that might allow parallelism to actually execute them simultaneously. But parallelism is not the goal of concurrency. The goal of concurrency is good structure. "},{"title":"1. Concurrency (Multi threading)","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#1-concurrency-multi-threading","content":" An application is making progress on more than one task at a time inside the application, resulting in a multi-threaded processIn contrast to: Sequential ExecutionWhen executing multi-threaded process on a processor, the processor can switch execution resources between threads, resulting in concurrent execution.When talking about concurrency we talk about something happen on a singe processor. Applications# goroutine in golang.JavaScript has a concurrency model based on an event loop.Promise in Javascript is asynchronous programming but not Concurrency. "},{"title":"2. Parallel Execution","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#2-parallel-execution","content":" A multi-threaded process executed in a shared-memory multi-CPU environment. threads are distributed among multiple CPUs at the same time. threads on different CPUs are executed in parallel. Parallel Execution is not equal to parallelism. "},{"title":"3. Parallel Concurrent Execution","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#3-parallel-concurrent-execution","content":" Simply the 1. Concurrency (Multi threading) + 2. Parallel Execution both happens. threads executed on a CPU are executed concurrently threads executed on different CPUs are executed in parallel. "},{"title":"4. Parallelism (Multi Processing)","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#4-parallelism-multi-processing","content":" When executing multi-processing program on multiple processors, tasks are split int sub-tasks and process by multiple threads.Resource are isolated among processors.Each process can have many threads running in its own memory space. Scenarios# multi-core processorsgraphics processing unit (GPU)field-programmable gate arrays (FPGAs)distributed computer clusters  "},{"title":"Coroutine v.s. Thread","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#coroutine-vs-thread","content":" Threads are scheduled by CPU. Coroutines are scheduled by User. Threads are typically preemptively scheduled. Coroutines are cooperatively scheduled. programs using threads must be careful about locking. programs using coroutines can often avoid locking entirely.  "},{"title":"Goroutine in Golang","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#goroutine-in-golang","content":" In short, Goroutine is something between thread and coroutine "},{"title":"Why Why goroutines instead of threads?","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#why-why-goroutines-instead-of-threads","content":"Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently executing functions—coroutines—onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won't be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: they have little overhead beyond the memory for the stack, which is just a few kilobytes. "},{"title":"Goroutine v.s. coroutine","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#goroutine-vs-coroutine","content":"goroutines imply parallelism; coroutines works on single thread.goroutines communicate via channels; coroutines communicate via yield and resume operationsgoroutines has controls of max thread number via $GOMAXPROCS set by user. "},{"title":"Reference","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#reference","content":"Summary of Concurrency Is Not Parallellism, a talk by Rob Pike並行程式設計: 概念Concurrency vs. ParallelismGolang FAQ: goroutines進程 (Process)、線程 (Thread)、協程 (Coroutine) 的概念講解Preemptive vs Non-Preemptive Scheduling: Key DifferencesGo Language Patterns: Coroutines當一個 goroutine 創建新的 goroutine 時，scheduler 會選誰優先執行？ "},{"title":"Encode, Hash and Encryption","type":0,"sectionRef":"#","url":"programming/encode-hash-encryption","content":"","keywords":""},{"title":"Encode","type":1,"pageTitle":"Encode, Hash and Encryption","url":"programming/encode-hash-encryption#encode","content":""},{"title":"Hash","type":1,"pageTitle":"Encode, Hash and Encryption","url":"programming/encode-hash-encryption#hash","content":""},{"title":"Encryption","type":1,"pageTitle":"Encode, Hash and Encryption","url":"programming/encode-hash-encryption#encryption","content":""},{"title":"Clean Code - Object Oriented Design","type":0,"sectionRef":"#","url":"programming/clean-code-note","content":"","keywords":""},{"title":"前言","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#前言","content":"公司新訓讀 Clean Code 紀錄。 "},{"title":"Inheritance 繼承","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#inheritance-繼承","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義","content":"繼承可以基於某個父類別對物件的定義加以擴充，而制訂出一個新的子類別定義。 子類別可以繼承父類別原來的某些定義子類別可以增加原來的父類別所沒有的定義子類別可以重新定義父類別中的某些特性 "},{"title":"優點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#優點","content":"子類可以輕鬆的擁有父類的方法來方便地實現對父類的擴展。 "},{"title":"缺點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#缺點","content":"父子之間的耦合度高，如果修改父類則子類也需要作出相應的修改，或是為了不同種子類而增加系統複雜度。 "},{"title":"使用繼承的時機:","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#使用繼承的時機","content":"Polymorphism兩者關係是 X 是 A 的一種，並且 X 是延伸 A 而不需要去修改 A 的情況，此情況以外的建議用 Composition。  "},{"title":"Composition 複合","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#composition-複合","content":"在我們對現實中的某些事物抽象成 Class 時，可能會形成很複雜的 Class，為了更簡潔的進行開發，我們經常把其中相對比較獨立的部分拿出來定義成一個個簡單的 Class，由這些簡單的 Class 再組成我們想要的類。Composition 最簡單的做法就是設計 Class 的時候把要組合的對象加入到自己之中作為自己的 local variable，也就是 has 的概念。 這樣的結果就是被加入的 Class 和目前的 Class 是一個低耦合狀態，不需要因為修改一個 Class 而連帶修改其他的 Class。 "},{"title":"優點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#優點-1","content":"開發的時候夠有彈性。 "},{"title":"缺點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#缺點-1","content":"容易產生過多的 Object。 "},{"title":"使用時機","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#使用時機","content":"當我們覺得當 A 有 X 能力的時候，像是鳥可以飛，就可以把 fly 當作變數加入鳥的 Class 裡。  "},{"title":"Law of Demeter","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#law-of-demeter","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義-1","content":"又稱作“最少知識法則”或“don’t talk to strangers”。如果一個 Object 知道了太多不屬於他本身的內容，則代表他和其他 Object 之間的耦合程度越高，在面對需要變更的時候難以修改。目的是要降低物件之間的依賴關係。 a method f of a class C should only call the methods of these: CAn object held in an instance variable of C.An object created by fAn object passed as an argument to fglobal variables 要先區分 Object 和 Data Structure，Object 這種以 Method 為核心的，才適用 Law of Demeter，Data structure 是以資料為核心，存取資料並不涉及行為，不違反 Law of Demeter。 "},{"title":"如何不違反","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#如何不違反","content":"Example 1 - 避免 method chainning# public boolean isValidEmployee(Employee employee) { String primaryEmailAddress = employee.getEmail().getPrimaryEmailAddress(); long mobile = employee.getContactNumber().getMobile(); if (primaryEmailAddress != null && mobile != 0) {return true;} return false; } Copy public boolean isValidEmployee(Employee employee) { //把檢查的責任歸屬放在employee內部 boolean isValidPrimaryEmailAddress = employee.isValidPrimaryEmailAddress(); boolean isValidMobile = employee.isValidMobile(); if (isValidPrimaryEmailAddress && isValidMobile) {return true;} return false; } Copy Example 2 - 只傳入函式需要知道的資訊。# public class Game { public Board board { get; private set; } public Game() { board = new Board(); } public void MarkBoard(int space, string marker) { board.spaces[space] = marker; //有問題 } } public class Board { public string[] spaces {get; private set;} public Board() { spaces = new string[] {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; } } Copy public class Game { public Board board { get; private set; } public Game() { board = new Board(); } public MarkBoard(int space, string marker) { board.Mark(space, marker) //呼叫board內的Mark實作。 } } public class Board { public string[] spaces {get; private set;} public Mark(int space, string marker) { spaces[space] = marker } public Board() { spaces = new string[] {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; } } Copy  "},{"title":"Inversion of Control (IoC)","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#inversion-of-control-ioc","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義-2","content":"Program 應該要依賴於抽象化介面，而不是實作細節，介面的功能應該以 Client 端的觀點定義。 "},{"title":"概念舉例","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#概念舉例","content":"今天有電腦(高層次)和記憶體(低層次)，還沒有實行 IoC 之前，電腦規格會依賴記憶體，如果更改記憶品牌則會導致問題，因為記憶體的細節規格不同。 IoC 的概念就是，應該要有 Interface 來把控制權轉換到Interface上，也就是名稱中 Inversion 的意思，電腦和 Interface 通常是 bundle 在一起的，實行後情況變成是，電腦依賴 Interface，記憶體也依賴 Interface ，也就是控制反轉了。  "},{"title":"Dependency Injection(DI)","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#dependency-injectiondi","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義-3","content":"傳統產生物件時，物件會自己產生自己需要的 dependency。 而 DI 則是產生物件時，此物件需要的 dependency 需由 Client 端提供，像是注入一樣。 "},{"title":"相關原則","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#相關原則","content":"衍生自相關原則： S.O.L.I.D. Principle 中的 Dependency Inversion principleInversion of Control（IoC) "},{"title":"概念","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#概念","content":"Object CompositionObject Lifetime ManagementObject Interception(Cross-Cutting-Concern) "},{"title":"Dependency Injection vs Composition","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#dependency-injection-vs-composition","content":"兩種都是把別的 Object 加入自己的 local variable 中，差異在哪？ //Dependency Injection class Employee { private Address address; public Employee( Address newAddress //注入 ) { this.address = newAddress; // 差異點 } public Address getAddress() { return this.address; } public void setAddress( Address newAddress //注入 ) { this.address = newAddress; } } Copy //Composition final class Car { private final Engine engine; Car(EngineSpecs specs) { engine = new Engine(specs); } void move() { engine.work(); } } Copy Dependency Injection: Address 和 Employee 彼此獨立存在，相互依賴。 Composition: The Engine 存在 Car 當中。 "},{"title":"Dependency Injection v.s. Functional Programming","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#dependency-injection-vs-functional-programming","content":"參考: Dependency rejection by Mark Seemann DI 跟 FP 的差異點在哪裡？# OO 跟 FP 的概念其實是根本上不同，FP 希望 function 是 pure 的，但 Dependecy 在 FP 的角度基本上是 impure，所以 Pure function 不能呼叫 impure function。但是 impure function 可以呼叫 pure function  "},{"title":"實行 Inversion of Control 的實際步驟","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#實行-inversion-of-control-的實際步驟","content":" Tightly coupled classesImplement IoC using factory patternImplement DIP by creating abstractionImplement Dependency InjectionDI containerLoosely coupled classes "},{"title":"Example","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#example","content":"Tightly coupled classes class Computer { // 依賴於低階模組：『具體』的英雄聯盟，而非 『抽象』的遊戲 private LOL lol; public Computer() { lol = new LOL(); } public Computer(LOL lol) { this.lol = lol; } public void playGame() { if (lol != null) lol.play(); } } class LOL { public void play() { System.out.print(\"LOL\"); } } Copy Implement IoC using factory pattern class Computer { public void playLOL() { LOL lol = new LOL(); lol.play(); } public void playWarcraft() { Warcraft warcraft = new Warcraft(); lol.play(); } } class LOL { public void play() { System.out.print(\"LOL\"); } } class Warcraft { public void play() { System.out.print(\"Warcraft\"); } } Copy Implement Dependency Injection public class Main { public static void main(String[] args) { GameFactory factory = new ImplGameFactory(); Game game = factory.createGame(); Computer computer = new Computer(game); } } class Computer { private Game game; // Constructor Injection public Computer(Game game) { this.game = game; } ... } Copy  "},{"title":"Reference","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#reference","content":"Clean CodeThe Law of DemeterDependency Injection 是什麼？Difference between dependency and composition?Dependency rejection by Mark Seemann控制反轉 (IoC) 與 依賴注入 (DI) "},{"title":"Design React Custom Hook","type":0,"sectionRef":"#","url":"react/react-custom-hook","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#intro","content":"從 React 開始力推 Functional Component 和 Hook 的搭配寫法後，貫徹了 Functional Programming 的思想，我們的 code 可讀性更高了，以下條列 Hook 的一些優點。 brings state(useState) and lifecycle(useEffect) features to functional component.separate functional logic from UI logic.composable with other hooks 除了原生的 hook（ex. useState，useEffect，useContext，useMemo，useCallback）之外，React 鼓勵我們寫 custom hook，方便我們把原生的 Hook 結合商業邏輯再次封裝，以便複用。 Custom hook 是一個很好的概念。 但是如何寫一個好的 Custom hook 呢？ "},{"title":"1. Naming Rule","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#1-naming-rule","content":"以use開頭，來被 React Linter 檢查使用方式。 Unlike a React component, a custom Hook doesn’t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it’s just like a normal function. Its name should always start with use so that you can tell at a glance that the rules of Hooks apply to it. "},{"title":"2. Scenario","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#2-scenario","content":""},{"title":"UI hooks - 把邏輯和 UI 分開","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#ui-hooks---把邏輯和-ui-分開","content":"保持 UI 組件 stateless / controlled把原生 useState, useEffect 封裝在 custom hook 裡並提供更方便的 API。ex. useInput, usePagination export const useInput = (initialValue = \"\") => { const [value, setValue] = useState(initialValue); const [focus, setFocus] = useState(false); return { value, focus, onChange: (e) => setValue(e.target.value), onFocus: () => setFocus(true), onBlur: () => setFocus(false), }; }; //... //in Input const { value, setValue, focus } = useInput(\"textInitial\"); return <input value={value} onChange={setValue(e.target.value)} />; Copy "},{"title":"Page hooks","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#page-hooks","content":"用 Custom Hook 分離 function / state / effect / API 呼叫等流程或商業邏輯保持頁面整潔ex. useYourPageNAme ... "},{"title":"Pure Function","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#pure-function","content":"也可以用 hook 封裝，但沒有必要。 "},{"title":"3. Generalized","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#3-generalized","content":"例如，如果要寫一個 Countdown 組件，寫了只能接收時間參數的 hook。 但 useInterval 可以讓 hook 更廣泛地被使用，只要傳入任何 callback 做一些事就好。 //1. useTimer const useTimer=(seconds)=>{ ... return {leftSecond} } //2. useInterval wins const useInterval = (callback, delay) => { ... return; }; //usage useEffect( useInterval(setCurrTime,1000),[] ); Copy "},{"title":"4. 適當的使用 useCallback","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#4-適當的使用-usecallback","content":"如果 custom hook 會被多處、多次使用，那添加 useCallback，避免不必要的 Function 多次宣告。下方以useHooks.com/useAsync為例。 const useAsync = (asyncFunction, immediate = true) => { const [status, setStatus] = useState(\"idle\"); const [value, setValue] = useState(null); const [error, setError] = useState(null); //4.適當的使用 useCallback const execute = useCallback(() => { setStatus(\"pending\"); setValue(null); setError(null); return asyncFunction() .then((response) => { setValue(response); setStatus(\"success\"); }) .catch((error) => { setError(error); setStatus(\"error\"); }); }, [asyncFunction]); useEffect(() => { if (immediate) { execute(); } }, [execute, immediate]); //5. 小心陳舊的閉包(Stale Closure) return { execute, status, value, error }; }; Copy "},{"title":"5. 小心陳舊的閉包(Stale Closure)","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#5-小心陳舊的閉包stale-closure","content":"同見上例，在 Custom Hooks 裡使用原生的 Hook 時一樣要小心 stale closure，useEffect 和 useCallback 的 dependency array 要正確的添加，才不會引用到過時的 state 或 function。 "},{"title":"6. 不要重複造輪子","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#6-不要重複造輪子","content":"可以先參考別人寫好的 Hook Library useHooks.comreact-use "},{"title":"Reference","type":1,"pageTitle":"Design React Custom Hook","url":"react/react-custom-hook#reference","content":"-How Are Function Components Different from Classes? -為什麼 Hook API 要有 dependencyArray：了解 hook Api 裡最要注意的 stale closure 的問題 "},{"title":"React Dev Notes","type":0,"sectionRef":"#","url":"react/react-dev-detail","content":"","keywords":""},{"title":"1. reducer of useReducer and updater function of setState will be called twice in strict mode.","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#1-reducer-of-usereducer-and-updater-function-of-setstate-will-be-called-twice-in-strict-mode","content":"reference: React.StrictMode causes setState to fire twice #12856should not perform side effect inside updater function "},{"title":"2. previous state of useReducer reducer and updater function of setState IS PASS BY REFERENCE.","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#2-previous-state-of-usereducer-reducer-and-updater-function-of-setstate-is-pass-by-reference","content":"Don't directly modify previous stateDeep copy previous state if you want to yous. "},{"title":"3. reducer should remain constant reference","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#3-reducer-should-remain-constant-reference","content":"Not working example const reducer = (state,action)=>{...} const getReducer = (someProps) => reducer; const [state, dispatch] = (getReducer(props), initialState); Copy props should by pass into reducer with action "},{"title":"4. return a function in useCallback","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#4-return-a-function-in-usecallback","content":"Purpose: Try to memoize the callback function getOnClick for Child.Assume We need information of index to get the real onClick callback. Not working example# only (idx)=>{...} is memoized, but not (e)=>{...} .Child is still getting newly created (e)=>{...} on every render. const getOnClick = useCallback((idx)=>(e)=>{...},[...]); const List = list.map((el,idx)=><Child onClick={getOnClick(idx)}/>); Copy Working example:# we can generate pass idx to Child, than (e)=>{...} is actually generated inside Child.getOnClick of Child is memoized by useCallback. const getOnClick = useCallback((idx)=>(e)=>{...},[...]); const List = list.map((el,idx)=><Child getOnClick={getOnClick)} idx={idx}/>); const Child = ({getOnClick, idx})=>{<div onClick={getOnclick(idx)}>...</div>} Copy "},{"title":"5. React.cloneElement to pass some props to props.children","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#5-reactcloneelement-to-pass-some-props-to-propschildren","content":"The resulting element will have the original element’s props with the new props merged in shallowly.original key and ref will be preserved const Wrapper = ({ children }) => { const wrappedChildren = React.cloneElement(children, { ...newProps }); return <>{wrappedChildren}</>; }; Copy "},{"title":"React Interview Questions","type":0,"sectionRef":"#","url":"react/react-interview-questions","content":"","keywords":""},{"title":"React","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#react","content":""},{"title":"1. What is the difference between writing React vs pure javascript","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#1-what-is-the-difference-between-writing-react-vs-pure-javascript","content":"We can definitely output some elements with javascript then append them to the DOM element. However, when talking to update and re-render, manipulating DOM is an expensive operation. React maintain a virtual DOM and do batch update to real DOM after calculating diff in Virtual DOM. "},{"title":"2. explain Class component vs Functional Component","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#2-explain-class-component-vs-functional-component","content":"Class component is stateful, Functional Component is stateless (natively)Debug with Functional Component is easier.Functional Component has more concise code.Functional Component is more suitable for reusing UI.Class component has more live cycleMemoize Class component with React.PureComponentMemoize Functional Component via the memo HOC "},{"title":"3. Explain when will Component re-render?","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#3-explain-when-will-component-re-render","content":"when the reference of props changed "},{"title":"State Management / Redux","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#state-management--redux","content":""},{"title":"4. React.Context v.s. Redux, why don't just use Context","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#4-reactcontext-vs-redux-why-dont-just-use-context","content":"//TODO Mainly is because of performance concern.React has its own bailout reconciliation mechanism to skip the re-rendering of a component. Context# When using Context, React will pass props implicitly to all nodes of subtree.When updating Context, React will recreate new context with Object.assign(), which will never bailout.Every Consumer or component that useContext will be update since the Context is always a new Object.The reason why React does not do reference check of a Context value is, React cannot ensure that developer is using immutable way to update Context. Reference# RFC: Context selectors #119深入 React Reconciliation Bailout 機制 "},{"title":"Compound Component","type":0,"sectionRef":"#","url":"react/react-compund-component","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#intro","content":"真實工作上遇到的問題，父組件是一個 Filter ，內部子組件依不同情況會有不同數量的 Input / Select / Radio / CheckBox，並且父組件要能控制子組件的內容(ex.重設等等)，原本的同事是利用 props 傳入 array 去決定 render 什麼內容，但這種方法一來在閱讀上有困難，二來會造成 props 這條路徑同時乘載 UI 內容和資料內容，這樣其實數量多起來閱讀會很混亂，開始思考要如何設計更好。 "},{"title":"What is Compound Component?","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#what-is-compound-component","content":"Compound components is a pattern where components are used together such that they share an implicit state that lets them communicate with each other in the background. A compound component is composed of a subset of child components that all work in tandem to produce some functionality. Compound component 的目的是提供一個更具表現力和靈活的 API，提供了一種表達組件之間關係的好方法。 白話一點來說，也是運用到props.children，父組件只要預設好子組件有哪些(甚至不用)，父組件不需要明確的表達子組件的內容。而是使用時，依不同情境去引入 chidren 的內容即可。 實際上有名的 Material UI和 Semantic UI也都採用了這種 UI 設計方法。 這個教學React Hooks: Compound Components介紹了基本的 Compound Component 設計。 <Toggle onToggle={(on) => console.log(on)}> <Toggle.On>The button is on</Toggle.On> <Toggle.Off>The button is off</Toggle.Off> <Toggle.Button /> </Toggle> Copy "},{"title":"Compound Component 實作: PopupFilter","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#compound-component-實作-popupfilter","content":"現在我們要建立一個 PopupFilter 有以下需求。 我們可以在不同情況下增減子組件。每個子組件都有自己的狀態。要能夠取得/管理子組件的狀態（defaultValue, reset, submit)。 檔案結構： |── PopupFilter ├── index.js ├── components ├── Header └── Footer └── DateRange └── Select └── Checkboxes └── index.js Copy // PopupFilter/index.js import React from 'react'; import { Popper, Grow } from '@material-ui/core'; import { ClickAwayListener } from '@material-ui/core'; import {Header,Select,DateRange,Checkboxes,Footer} from './components'; const PopupFilter = ({ open, anchorEl, children, onClose }) => { return ( <Popper open={open} anchorEl={anchorEl} transition > <div>{children}</div> </Popper> ); }; PopupFilter.Header = Header; PopupFilter.Footer = Footer; PopupFilter.Select = Select; PopupFilter.DateRange = DateRange; PopupFilter.Checkboxes = Checkboxes; export default PopupFilter; //Page.js const Page=()=>{ const [open,setOpen]=React.useState(false); const handleClose=()=>setOpen(false); return( <PopupFilter open={open} onClose={handleClose}> <PopupFilter.Header /> <PopupFilter.Checkboxes label={'CheckBox'} options={...} /> // ... <PopupFilter.Select label={'Select1'} options={...} /> <PopupFilter.Select label={'Select2'} options={...} /> <PopupFilter.DateRange label={'DateRange'} /> <PopupFilter.Footer /> <OtherChildren/> </PopupFilter>) } Copy 好了，看起來其實很簡單，也是使用到 children，讓不同使用情境自行增減，但目前都還沒有考慮到狀態管理的問題。 "},{"title":"狀態管理 State Management","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#狀態管理-state-management","content":"現在，子組件並未受到父組件控制。 我們要如何管理子組件的 state（ex. defaultValue，handleChange，handleReset，getResult ...）？因為這種做法父組件不會提前知道子組件有什麼內容，所以也無法預設有多少個子組件的 state 要管理。其實是比父組件更上層的頁面組件才會知道當下子組件有多少個。 "},{"title":"1. 把 state 都放在頁面組件裡","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#1-把-state-都放在頁面組件裡","content":"這是最直覺的，lift state up，但是當組件增加時頁面就會變得混亂。結果將會出現一堆狀態和 handleChange。 2. Custom hook# 將 state / update/ reset 的邏輯放在 hook 裡，我們將其稱為 usePopupFilter。 那回到剛剛的問題，要如何動態的幫子組件建立 state 呢？我們可以讓 usePopupFilter return 一個 register 的方法 \b，每個需要控制狀態的子組件提供不重複的 key，使用 register 來註冊自己在 state 中的位置。 在頁面中，我們只是使用 custom hook 取得結果的最新狀態，保持頁面的簡潔和可讀性，既優雅又簡潔。 //usePopupFilter.js import { useState, useEffect, useCallback } from \"react\"; import { useImmer } from \"use-immer\"; const usePopupFilter = ({ defaultValue }) => { const [state, setState] = useState({ data: { ...defaultValue } }); const { data } = state; //提供子組件「註冊」一個state Object的key欄位，並回傳子組件需要的prop const register = useCallback( (key) => ({ value: data[key], defaultValue: defaultValue[key], onChange: (value) => setState((state) => (state.data[key] = value)), }), [data] ); //提供onSubmit傳入並讀取data const handleSubmit = useCallback( (onSubmit) => () => { onSubmit(data); }, [data] ); const reset = useCallback(() => { setState((state) => (state.data = defaultValue)); }, []); return { state, register, handleSubmit, reset }; }; export default usePopupFilter; Copy "},{"title":"實際使用","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#實際使用","content":"import React, { useState, useEffect } from 'react'; import PopupFilter from './PopupFilter'; import usePopupFilter from 'Hooks/usePopupFilter'; export const PopupFilterDemo = () => { const [open, setOpen] = useState(false); const { state, register, handleSubmit, reset } = usePopupFilter({ defaultValue: { checkbox: [options1[1]], }, ... }); const handleOpen = () => { setOpen(!open); }; const handleClose = () => setOpen(false); const onFilter = data => { handleClose(); handleSubmit_(); }; const handleSubmit_=()=>{ ... } return ( <div > <button onClick={handleOpen}>OpenFilter</button> <PopupFilter open={open} onClose={handleClose}> <PopupFilter.Header onClick={reset} /> <PopupFilter.Checkboxes label={'CheckBox'} options={options1} {...register('checkbox')} /> <PopupFilter.Select label={'Select'} options={options2} {...register('select')} /> <PopupFilter.Select label={'Select2'} options={options2} {...register('select2')} /> <PopupFilter.DateRange label={'DateRange'} {...register('DateRange')} /> <PopupFilter.Footer onClick={handleSubmit(onFilter)} /> </PopupFilter> </div> ); }; const options1 = [ { value: '1', label: 'option1' }, { value: '2', label: 'option2' }, { value: '3', label: 'option3' }, ]; const options2 = [ { value: '1', label: 'select1' }, { value: '2', label: 'select2' }, { value: '3', label: 'select3' }, ]; Copy "},{"title":"Reference","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#reference","content":"React Hooks: Compound ComponentsMaster the Compound Component PatternReact.js Building Your Own Hooks "},{"title":"3 Ways To Pass Values From Child to Parent","type":0,"sectionRef":"#","url":"react/react-parent-child-pass-value","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#intro","content":"雖然 React 鼓勵我們提升 state ，將 UI 拆解為小組件，並使用 props 從父組件到子組件傳遞數據。 延伸閱讀: 從 React Prop Drilling 來看 Design Pattern 但在設計流程上，提升 state 其實是有點反設計直覺的，已經設計好的子組件會放到不同父組件內，但總不會一直花時間把它的 state 提升到 Parent，不合成本也會造成 code 的重複，也不會全部 UI state 都交給 redux 處理，總會遇到需要把 state 放在 children，需要再從 children 把更新的資料傳回 parent 的時候，也就是加入反向的資料流，例如這個例子。 簡單記錄幾個用過的方法。 "},{"title":"1. Callback Function","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#1-callback-function","content":"這個方法每次 onChange 都會執行一次。 但要注意如果在 Parent 有執行 setState 的話，Child 也會每次 onChange 就被重新 render，如果考慮到效能的話可以考慮使用第 2 種方法。 const Parent = () => { const [childState,setChildState]=useState(null) const getValue = (v) => {setChildState(v)}; return <Child getValue={getValue} />; }; const Child = ({ getValue }) => { const handleChange=(e)=>{ someThingElse(e); getValue(e.target.value); } return( <input onChange={handleChange} /> )}; } Copy "},{"title":"2. Pass Ref to Child","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#2-pass-ref-to-child","content":"當我們只想要在某些情況(ex.提交表單)時取得 Child 的值，我們可以傳遞 ref 給 Child，需要使用時再從 ref 的 callback ref.current 取得最新的值。這樣不會像第 1 種方法造成 Child 重新 render。 const Parent = () => { const childRef = useRef(null); return ( <> <Child ref={childRef} type='input' /> <button onClick={() => { alert(childRef.current.value); }} > Click Input </button> <Child ref={childRef} type='checkbox'/> <button onClick={() => { alert(childRef.current.checked); }} > Click checkbox </button> <Child ref={childRef} type='select'/> <button onClick={() => { alert(childRef.current); }} > Click checkbox </button> ... </> ); }; const Child = ({ ref,type}) => { switch (type){ case 'input': return <input ref={ref} /> case 'checkbox': return <checkbox ref={ref} /> case 'select': return <select onChange={(v)=>{ref.current=v}} /> ... } } Copy "},{"title":"3. 使用 useImperativeHandle 命令式(不常見)","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#3-使用-useimperativehandle-命令式不常見","content":"React 官網介紹: Reac.js useImperativeHandle useImperativeHandle customizes the instance value that is exposed to parent components when using ref. As always, imperative code using refs should be avoided in most cases. useImperativeHandle should be used with forwardRef 其實不確定 React 為什麼不建議使用。 這個方法的使用時機是，當 Parent 需要控制 Child 內部的 function，Child 可以把想要對 Parent 暴露的 funciton 放在 useImperativeHandle 中給 Parent 使用。常見用法例如使 Child focus、blur、reset等等。比較不常用在取得 value，不過要用也是可以用，因此也列出來。 codeSandbox import React,{useImperativeHandle,forwardRef,useRef} from \"react\"; const Child = forwardRef((props, ref) => { const childRef = useRef(null); useImperativeHandle(ref, () => ({ forceBlur: () => { inputRef.current.blur(); }, forceReset()=>{ //... }, getValue:()=>childRef.current.value })); return <input ref={childRef} />; }); const Parent = () => { const childRef = useRef(); return ( <> <Child ref={childRef} /> <button onClick={() => { childRef.current.forceBlur(); alert(childRef.current.getValue()); }} > Click </button> </> ); }; Copy "},{"title":"Performance Optimization of React","type":0,"sectionRef":"#","url":"react/react-performance-optimization","content":"","keywords":""},{"title":"Terms","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#terms","content":"// TODOhttps://developer.chrome.com/docs/devtools/evaluate-performance/reference/ "},{"title":"Memoization","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#memoization","content":""},{"title":"Why do they need to remember?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#why-do-they-need-to-remember","content":"Computation is expensiveKeep consistent reference to the memory addressReduce unnecessary re-render of a component "},{"title":"What do they remember?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#what-do-they-remember","content":"React.memo: a ComponentuseCallback: a functionuseMemo: a valueuseRef: a value "},{"title":"When do they remember?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#when-do-they-remember","content":"React.memo: when equality function returns falseuseCallback: when dependency changeuseMemo: when dependency changeuseRef: when assign value to ref.current "},{"title":"Declare function & constant outside vs inside component?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#declare-function--constant-outside-vs-inside-component","content":"Outside component: will not be re-created on every render.Inside component: will be re-created on every render. "},{"title":"Ways to Memoize a constant / Object","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#ways-to-memoize-a-constant--object","content":"declare outside component If the value is irrelevant to props, just declare outside component.useMemo: const memoizedValue = useMemo(objFromProps,[dependencies])useRef: const memoizedValue = useRef(objFromProps)p.s. useMemo(initialValue,[]) works same as useRef(initialValue) "},{"title":"Ways to Memoize a function","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#ways-to-memoize-a-function","content":"declare outside component If the function is irrelevant to props, just declare outside component.const memoizedFunction = useCallback(funcFromProps,[dependencies]) "},{"title":"How to Prevent unnecessary re-render of a component","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#how-to-prevent-unnecessary-re-render-of-a-component","content":"useCallback in parent to memoize method props.useMemo to memoize non-primitive-type value.Wrap component with React.memo and check the equality of props.  "},{"title":"How to Inspect?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#how-to-inspect","content":""},{"title":"Chrome DevTools Performance","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#chrome-devtools-performance","content":"//TODO "},{"title":"React Profiler","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#react-profiler","content":"Install React Developer ToolsOpen Chrome Devtools -> [Profiler] TabSettings -> General -> [v] Highlight updates when components render. "},{"title":"Profiler API","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#profiler-api","content":"import React, { Profiler } from \"react\"; const CustomStockChart = (props) => { // ... return ( <Profiler id=\"StockChart\" onRender={logTimes}> <StockChart>{/* ... */}</StockChart> </Profiler> ); }; const logTimes = (id, phase, actualTime, baseTime, startTime, commitTime) => { console.log(`${id}'s ${phase} phase:`); console.log(`Actual time: ${actualTime}`); console.log(`Base time: ${baseTime}`); console.log(`Start time: ${startTime}`); console.log(`Commit time: ${commitTime}`); }; export default CustomStockChart; Copy "},{"title":"Meaning of Profiling value","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#meaning-of-profiling-value","content":"id: string - The id prop of the Profiler tree that has just committed. This can be used to identify which part of the tree was committed if you are using multiple profilers. phase: \"mount\" | \"update\" - Identifies whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks. actualDuration: number - Time spent rendering the Profiler and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. React.memo, useMemo, shouldComponentUpdate). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change. baseDuration: number - Duration of the most recent render time for each individual component within the Profiler tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). "},{"title":"Reference","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#reference","content":"A Closer Look at React Memoize Hooks: useRef, useCallback, and useMemoIntroducing the React Profiler使用 React Profiler 來觀察 React Web App 的渲染狀況並進行效能優化Chrome: Performance features reference tags: React# "},{"title":"React v.s. Vue","type":0,"sectionRef":"#","url":"react/react-vs-vue","content":"","keywords":""},{"title":"tl;dr","type":1,"pageTitle":"React v.s. Vue","url":"react/react-vs-vue#tldr","content":"In React, you output everything from DOM markup. In Vue, you energize template markup. In React, data flows down into the DOM markup. In Vue, data flows up into the DOM markup. React is one-way data flow. Vue is two-way binding. "},{"title":"Intro","type":1,"pageTitle":"React v.s. Vue","url":"react/react-vs-vue#intro","content":"前端發展快快速，newbie 總會思考到底該學哪個前端框架，選擇因素包含個人喜好、工作機會、使用族群、社群廣泛度等等。那學了一個還要學第二個嗎？學了多個就會變資深嗎？ 剛開始是學 React，很多人說 Vue 學起來更簡單，社群也在逐漸增加，但更簡單就是好嗎？更簡單我猜測意味著框架幫你把一些事情做掉了，只要使用他提供的 API 即可。Vue 的確提供了更多的 API，例如不用自己寫 handleChange，可以不用管 Lifecycle。React 還要自己寫這些。 原本因個人喜好到現在還是沒有真正寫過 Vue，只有看過一些教學文章。但後來發現 React 夠熟悉抽象化邏輯，更能看清楚兩者差異，即使之後要改寫 Vue 應該也可以快速上手，其實最大的差異就是在 Vue 寫 template markup 跟 React 寫 DOM markup 的差別，一個是 render 後，一個是 render 前。下方文章用抽象蠻好的描述了兩者差異。 另外是，發現 Vue3.0 推出，在 functional programming 上跟 React 走更近了。 "},{"title":"React & Hook / Vue Composition API","type":1,"pageTitle":"React v.s. Vue","url":"react/react-vs-vue#react--hook--vue-composition-api","content":"React & Hook\tVue Composition APIContext: Provider & Consumer\tprovide & inject state: useState\tref state: derived state\tcomputed(() => state.value...) Lifecycle: useEffect(,[]) & ComponentDidMount\tsetup() Lifecycle: useEffect\twatchEffect(()=>{mutate state here} ) "},{"title":"Vue vs React 對比的想法 (附上不專業翻譯)","type":1,"pageTitle":"React v.s. Vue","url":"react/react-vs-vue#vue-vs-react-對比的想法-附上不專業翻譯","content":"But my opinion very importantly hinges upon knowledge of immutable, unidirectional data flow patterns that I learned in React. Knowing those made me a better developer period. React is more like writing pure JavaScript modules in node.js. React 更像是在 node.js 中編寫純 JavaScript module。 Both React and Vue are all about that single-file component life. React 和 Vue 都與 single-file 組件的 lifecycle 有關。 I think we need both and should keep both around. In both you are standing beside a river of data flow. 在這兩種方法中，您都站在 data flow 旁。 In React, you are standing upstream of the render loop. 在 React 中，您位於 render loop 的上游。 In Vue, you are standing downstream of the render loop. 在 Vue 中，您位於 render loop 的下游。（更像在寫 template) In this way, they are the inverse of each other. 在這方面他們彼此相反。 Vue is like inside-out React. In React, you output DOM markup. 在 React 中，你輸出 DOM markup。 In Vue, you energize template markup. 在 Vue 中，你使 template markup 動起來。 In React, data flows down into the DOM markup. 在 React 中，數據向下流入 DOM markup。 In Vue, data flows up into the DOM markup. 在 Vue 中，數據向上流入 DOM 標記。 At the end of the day, I just want access to pure JavaScript everywhere, instantly. React and Vue both give me that. In both, if you focus on making as many stateless, deterministic components as possible, you will always have an impressive set of atomically composable SFCs around, and you can slap the roof on those badboys and put them into any state container components. Often times I am surprised I get paid to do this stuff because I just love it. There is something abstract-geometrically beautiful about composing algebraic types within continuous and differentiable data flows. 歸根究底，我只想立即在任何地方訪問純 JavaScript。 React 和 Vue 都給了我。 在這兩種方法中，如果您專注於製造盡可能多的 stateless，確定性組件，則始終會有一組令人印象深刻的原子可組合 SFC，並且可以在這些壞傢伙身上搭起屋頂，並將它們放入任何狀態容器組件中。 很多時候，我很驚訝我會因為做這件事而得到報酬，因為我只是喜歡它。 在連續且可區分的 data flow 中組成代數類型在某種程度上具有抽象幾何的美。 Try Vue with Tailwind and you will really blow your mind if you have passion for atomic design. "},{"title":"Reference","type":1,"pageTitle":"React v.s. Vue","url":"react/react-vs-vue#reference","content":"React Hooks vs Vue 3 Composition APIVue-單一元件檔(Single-file components)Just started vue coming from react. Does anyone else feel that vue makes RIDICULOUSLY more sense than react?? "},{"title":"Props Drilling and State Management","type":0,"sectionRef":"#","url":"react/react-prop-drilling","content":"","keywords":""},{"title":"What is Prop Drilling?","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#what-is-prop-drilling","content":"Many articles see prop drilling is a problem.But it is actually an design pattern.Remind that when we first learn React, we learned: Lifting State Up Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. This is one of the design patterns for state management "},{"title":"Pros of Prop Drilling","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#pros-of-prop-drilling","content":"good for reusing UIno extra abundanceeasy for pros tracing  "},{"title":"Why is Prop Drilling a Problem","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#why-is-prop-drilling-a-problem","content":"Think about below scenario. ComponentNeedingProps is the component who really need contentComponentNeedingProps is deeply nested inside FirstComponent, SecondComponent and ThirdComponent while they three don't actually need contentWhen there are more of these kind of prop, it brings difficulties on maintaining code. export default function App() { return ( <div className=\"App\"> <FirstComponent content=\"Who needs me?\" /> </div> ); } function FirstComponent({ content }) { return ( <div> <h3>I am the first component</h3>; <SecondComponent content={content} />| </div> ); } function SecondComponent({ content }) { return ( <div> <h3>I am the second component</h3>; <ThirdComponent content={content} /> </div> ); } function ThirdComponent({ content }) { return ( <div> <h3>I am the third component</h3>; <ComponentNeedingProps content={content} /> </div> ); } function ComponentNeedingProps({ content }) { return <h3>{content}</h3>; } Copy "},{"title":"Solutions","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#solutions","content":""},{"title":"1. Pass component in props.children","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#1-pass-component-in-propschildren","content":"props.children is an attribute returns by React.createElement​. It refers to child node.We can pass contents like HTML tag、component down to child componentwe just hide the pros drilling inside children.Reference: Children in JSX function App() { const content = \"Who needs me?\"; return ( <div className=\"App\"> <FirstComponent> <SecondComponent> <ThirdComponent> <ComponentNeedingProps content={content} /> <ThirdComponent> </SecondComponent> </FirstComponent> </div> ); } //rewrite function FirstComponent({ content }) { return ( <div> <h3>I am the first component</h3>; {children} </div> ); } Copy "},{"title":"2. Context API","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#2-context-api","content":"Using Context API to Context.Consumer and render it with render props方式接收。Another design pattern: Provider Pattern。 export default function App() { return ( <div className=\"App\"> <Context.Provider value={content}> <FirstComponent content=\"Who needs me?\" /> </Context.Provider> </div> ); } function ComponentNeedingProps() { const content = Context.Consumer; return <Context.Consumer>{(content) => <h3>{content}</h3>}</Context.Consumer>; } Copy "},{"title":"3. State management tools ex.Redux, Mobx...","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#3-state-management-tools-exredux-mobx","content":" "},{"title":"Redux v.s. Context API","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#redux-vs-context-api","content":"Why don't we just replace Redux with native Context? "},{"title":"Same","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#same","content":"both are for state managementboth to avoid props drilling "},{"title":"Redux","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#redux","content":"Redux construct an global 的 store to store all state.Redux is single data flow (FLUX)Redux update store with action(constant) and reducer (pure function)react-redux: every component inside Provider can use connect HOF or useSelector hook to subscribe to some part of the state. Pros# provide middleware-friendly API to let you do something between action and reducer, (ex. redux-thunk, redux-saga)good definition based on FLUX: store/reducer/actionuseSelector hook to subscribe state change。 Cons# more dependencymore definition and naming (action,reducer) "},{"title":"React Context API","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#react-context-api","content":"hooks: createContext, useContext# Pros# native in React, no extra dependencyflexiblecan use multiple Provider state Cons# too little definition, may cause difference in codes.When a context value is changed, all components that useContext will re-render. When the nearest MyContext.Provider above the component updates, this Hook will trigger a re-render with the latest context value passed to that MyContext provider. Even if an ancestor uses React.memo or shouldComponentUpdate, a re-render will still happen starting at the component itself using useContext. Update 2021: use-context-selector# is currently developinguseContextSelector: This hook returns context selected value by selector.It will only accept context created by createContext. It will trigger re-render if only the selected value is referentially changed. "},{"title":"Conclusion","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#conclusion","content":"Redux is still an popular state management solution for large applications.if in smaller application or performance is not an issue, Context could be a good solution too.they can be used together  "},{"title":"reference","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#reference","content":"How To Avoid Prop Drilling in React Using Component CompositionReact 狀態管理模式 "},{"title":"Redux and Flux","type":0,"sectionRef":"#","url":"react/redux-flux","content":"","keywords":""},{"title":"Flux","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#flux","content":"Video Hacker Way: Rethinking Web App Development at FacebookFlux is more an application architecture / design pattern than a framework.Redux is one kind of implementation of Flux. "},{"title":"Flux Architecture","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#flux-architecture","content":" "},{"title":"Flux and Redux","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#flux-and-redux","content":" "},{"title":"Why Flux?","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#why-flux","content":"MVC doesn't scale, it becomes unpredictable when scaling because: data flow in MVC tend to be difficult to understand, to trace bug Flux use unidirectional data flow: action -> store -> view for more understandable mental model than MVC.Flux internalize the control into view: so that state is very next to the logic of state update, easier to maintain consistency.Flux structure helps separate view state from data "},{"title":"Benefits of Flux","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#benefits-of-flux","content":"Improve data consistencyEasier to pinpoint a bug "},{"title":"Stores","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#stores","content":"Do: listen to action ( bindListeners in alt.js)performs state update based on action payload (reducer in redux)manage the state of many objectsbroadcast an event declaring that their state has changed "},{"title":"Controller-Views","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#controller-views","content":"Do: listen to the changes from store and re-renderget the data from the storespass this data down the chain of its descendants  "},{"title":"Extension","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#extension","content":""},{"title":"Store: Singleton Pattern","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#store-singleton-pattern","content":"Singleton Pattern is a design pattern that restricts the instantiation of a class to one object. There is only one state tree known as Store in Redux.Store is Single source of truth. "},{"title":"Connect/Selector: Observer Pattern","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#connectselector-observer-pattern","content":"An object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes. "},{"title":"applyMiddleware: Decorator Pattern / HOF","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#applymiddleware-decorator-pattern--hof","content":"designed to enhance functionality, but does not change the interface "},{"title":"Reference","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#reference","content":"FluxAn introduction to the Flux architectural patternAn Obsession with Design Patterns: ReduxDifference between redux and flux "},{"title":"Distributed Cache","type":0,"sectionRef":"#","url":"system/distributed-cache","content":"","keywords":""},{"title":"Requirements","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#requirements","content":""},{"title":"Functional","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#functional","content":"putget "},{"title":"Non-functional","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#non-functional","content":"performancescalabilityavailabilitydurability "},{"title":"LRU Cache","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#lru-cache","content":"cache policy is important because if the target data always not in the cache, it only increase overhead.most popular cache replacement policies: Discards the least recently used items first (i.e. LRU cache)Leetcode 146. LRU Cache "},{"title":"Distributed","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#distributed","content":"cache host only store chunk of data, i.e. shardcache client library inside the service knows about all shards and forward request to a particular shard with TCP / UDP. "},{"title":"Dedicated cache cluster","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#dedicated-cache-cluster","content":"cache host is isolated from service host. Pros: cache host can be used by multiple services. Pros: flexibility in choosing hardware. "},{"title":"co-located cache","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#co-located-cache","content":"we run cache as a separate process on a host. Pros: no extra hardware or operational cost Pros: scale together with service. "},{"title":"Hash","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#hash","content":"How do cache client decide which cache shard to call? "},{"title":"MOD hashing","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#mod-hashing","content":"HashHostIdx = HashFunction(key) % NumberOfCacheHosts Copy usually not feasible for production.Cons: When cache host add or deleted, high probability of cache misses because all nodes are affected. "},{"title":"consistent Hashing","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#consistent-hashing","content":" Pros: When cache host add or deleted, only small subset (neighbors) of nodes are affected. Domino Effect# when one node dies the load may transferred to another nodethen cause another dies as well, causing chain reaction. Uneven Distribution# can solve with Virtual Nodes, Jump Hash, Proportional Hashing Virtual NOdes# instead of positioning a single spot per node on ring, we can position more than one spot per node.  "},{"title":"Cache Client","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#cache-client","content":"is: a librarystores: list of cache hosts in sorted order.responsible for: cache host selection (can use binary search). How do we maintain the list of cache client ?  "},{"title":"Static server list","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#static-server-list","content":"store as a fileCons: not flexible, need to re-deploy when hosts change manually. "},{"title":"Dynamic server list","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#dynamic-server-list","content":"use configuration service (e.g. ZooKeeper, Redis Sentinel)cache host sends heartbeat to the config service periodically.Pros: fully automate list maintenance "},{"title":"Data replication","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#data-replication","content":"How to achieve high availability in high QPS (hot shard)? Data replication we discuss async leader-follower data replication here.structure and implementation are based on DDIA CH5: Replication - Leaders and FollowersPut: only through leaderGet: can through leader and followerFailover: can be implemented by Cache Client "},{"title":"What Else Important","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#what-else-important","content":""},{"title":"Potential Inconsistency","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#potential-inconsistency","content":"when partition appears, may get stale result from follower.when some cache nodes are down, some cache shards are not available.Discussion: tradeoff between sync and async replication. "},{"title":"data expiration","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#data-expiration","content":"passively expire cache on get requestmaintenance thread runs regularly "},{"title":"local cache","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#local-cache","content":"can implemented local cache as welle.g. Guava Cache "},{"title":"security","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#security","content":"ensure only the approved client can access the cachemay encrypt and decrypt cache when put and get cache. "},{"title":"monitoring and logging","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#monitoring-and-logging","content":"number of faults while calling the cachelatencynumber of hits and missesCPU and memory utilization on cache hostsnetwork I/O "},{"title":"Summary","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#summary","content":" "},{"title":"Reference","type":1,"pageTitle":"Distributed Cache","url":"system/distributed-cache#reference","content":"System Design Interview - Distributed Cacheconsistent hashing in PythonConsistent Hashing Algorithm: 應用情境、原理與實作範例NoSQL Essentials: Cassandra "},{"title":"C.A.P Theorem","type":0,"sectionRef":"#","url":"system/cap","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#intro","content":"The CAP Theorem says that it is impossible to build an implementation of read-write storage in an asynchronous network that satisfies all of the following three properties: Availability: will a request made to the data store always eventually complete?Consistency: will all executions of reads and writes seen by all nodes be atomic/linearizably consistent?Partition tolerance: the network is allowed to drop any messages. A partition is a communications break within a distributed system—a lost or temporarily delayed connection between two nodes.  "},{"title":"Consistency Models","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#consistency-models","content":"Consistency Model is contract between a distributed data system (e.g., DFS, DSM) and processes constituting its applications "},{"title":"Taxonomy of consistency model.","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#taxonomy-of-consistency-model","content":" "},{"title":"Trade Offs","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#trade-offs","content":"↑ Consistent, Complex ↑ LinearizabilitySequential consistencyCausal consistencyEventual consistency ↓ Available, Low Latency, Feasible, Scalable ↓ "},{"title":"Linearizability (C > A)","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#linearizability-c--a","content":"Should provide the behavior of a single copyThe ordering of operations is determined by time.A read operation returns the most recent write, regardless of the clients.All subsequent read ops should return the same result until the next write, regardless of the clients.Cons: implementation requires absolute global time  What happens if you don't have Linearizability?#  "},{"title":"Sequential Consistency","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#sequential-consistency","content":"Should provide the behavior of a single copy. The ordering of operations is determined by the program order of each client. Reads may be stale in terms of real time, but not in logical time. A read operation returns the most recent write, regardless of the clients. Writes are totally ordered according to logical time across all replicas Cons: requires highly available connections "},{"title":"Causal Consistency","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#causal-consistency","content":"Writes that are potentially causally related must be seen by all machines in same order.Concurrent writes may be seen in a different order on different machines. "},{"title":"Eventual consistency (A > C)","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#eventual-consistency-a--c","content":"Is: Allow stale reads, but ensure that reads will eventually reflect previously written values. Doesn’t order concurrent writes as they are executed, which might create conflicts later: which write was first? Pros: High data availability (A) Pros: High concurrency opportunities Pros: Support disconnected operations or network partitions Better to read a stale value than nothingBetter to save writes somewhere than nothing Cons: may displaying stale data Cons: may violate Atomic Consistency NoSQL databases that manage non-structured data are often good choices for eventual consistency models.  "},{"title":"CP/AP: a false dichotomy","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#cpap-a-false-dichotomy","content":"The fact that we haven’t been able to classify even one datastore as unambiguously AP or CP should be telling us something: those are simply not the right labels to describe systems. Within one piece of software, you may well have various operations with different consistency characteristics. Many systems are neither consistent nor available under the CAP theorem’s definitions. However, I’ve never heard anyone call their system just “P”, presumably because it looks bad. But it’s not bad – it may be a perfectly reasonable design, it just doesn’t fit one of the two CP/AP buckets. Even though most software doesn’t neatly fit one of those two buckets, people try to shoehorn software into one of the two buckets anyway, thereby inevitably changing the meaning of consistency or availability to whatever definition suits them. Unfortunately, if the meaning of the words is changed, the CAP theorem no longer applies, and thus the CP/AP distinction is rendered completely meaningless. A huge amount of subtlety is lost by putting a system in one of two buckets. There are many considerations of fault-tolerance, latency, simplicity of programming model, operability, etc. that feed into the design of a distributed systems. It is simply not possible to encode this subtlety in one bit of information. For example, even though ZooKeeper has an AP read-only mode, this mode still provides a total ordering of historical writes, which is a vastly stronger guarantee than the AP in a system like Riak or Cassandra – so it’s ridiculous to throw them into the same bucket. Even Eric Brewer admits that CAP is misleading and oversimplified. In 2000, it was meant to start a discussion about trade-offs in distributed data systems, and it did that very well. It wasn’t intended to be a breakthrough formal result, nor was it meant to be a rigorous classification scheme for data systems. 15 years later, we now have a much greater range of tools with different consistency and fault-tolerance models to choose from. CAP has served its purpose, and now it’s time to move on. "},{"title":"Reference","type":1,"pageTitle":"C.A.P Theorem","url":"system/cap#reference","content":"The CAP FAQCAP 定理 101—分散式系統，有一好沒兩好Please stop calling databases CP or APConsistency models of NoSQL databasesCSE 486/586 Distributed Systems Consistency --- 2Lec 12: Consistency Models – Sequential, Causal, and Eventual Consistency "},{"title":"Web Authentication","type":0,"sectionRef":"#","url":"web-dev/web-auth","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#intro","content":"HTTP request is stateless. "},{"title":"Terms","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#terms","content":""},{"title":"Token","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#token","content":""},{"title":"OAuth","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#oauth","content":" "},{"title":"Session Based Authentication","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#session-based-authentication","content":"為解決 http 是stateless的特性之下，儲存 user 紀錄。Cookie: 在瀏覽器內儲存資料，原本儲存使用者資料，但因為容易被修改/暴露，則改存 Session ID。Session: 負責紀錄在 server 端上的使用者訊息，會在一個用戶完成身分認證後，存下所需的用戶資料，接著產生一組對應的 ID，存入 cookie 後傳回用戶端。 "},{"title":"Token Based Authentication: JWT? (JSON Web Tokens)","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#token-based-authentication-jwt-json-web-tokens","content":" 用途: 一般被用來在 身份提供者 和 服務提供者 間傳遞被 認證 的用戶身份訊息，以便於從資源伺服器獲取資源。 一次性驗證跨伺服器登入 內容: header: 存放 token 型別與加密方式，經過 base64 編碼。payload: 存放需要傳遞的訊息(ex. iss: 發行人, exp: 到期日, sub: 主題...)，經過 base64 編碼。signature: 存放加密過後的內容。由 header (base64)+payload (base64)+secret 組成。 HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), 'secret') Copy "},{"title":"Reference","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#reference","content":"不要用 JWT 替代 session 管理（上）：全面了解 Token,JWT,OAuth,SAML,SSO "},{"title":"Node.js Streaming Server-Side Rendering","type":0,"sectionRef":"#","url":"web-dev/ssr-stream","content":"","keywords":""},{"title":"TL:DR","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#tldr","content":"React can be a lost faster than client side rendering.Straming enables page performance to stay constant.We need to think our page as separately renderable pieces.The scenario is usually high performance server and lower performace client browser/device and slow network "},{"title":"Review the rendering work flow","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#review-the-rendering-work-flow","content":" "},{"title":"Intro - Different Types of Rendering Flow","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#intro---different-types-of-rendering-flow","content":" see more on Rendering on the Web "},{"title":"1. Client Side Rendering","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#1-client-side-rendering","content":" client requestserver returns small html with no infoclient request doc header and request JS and CSSclient parse JS & CSSclient browser painting meanwhile request for data from APIAPI returns dataclient use ReactDOM.render() to revive the DOM once you have both Javascript and JSON dataclient shows full page and become interactive Pros and Cons# pros: no need dynamic servercons: slow cuz jobs are done in serialcons: slow cuz parsing javascript is expensive "},{"title":"2. Server Side Rendering","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#2-server-side-rendering","content":" client requestserver return only HTML header to clientclient request for JS and CSS based on HTML headerserver meanwhile make request to API serverserver load data on the server side and use ReactDOMServer.renderToString() to create HTML markupclient parsing JS and CSSserver send the data down in a script tag or via HTTP/2 Server Push. (first contentful paint)client become interactive when step 6 is done (Time to Interactive) noted that: 3 and 4 can be parallel5 and 6 can be parallel Pros and Cons# pros: faster than client side rendering cuz job can be done in parallelpros: faster than client side rendering cuz server usually has better performance than clientcons: needs dynamic web servercons: Don't scale, Time to Interactive increase when more feature (JS and CSS) added on page.  "},{"title":"Terms","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#terms","content":""},{"title":"flush()","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#flush","content":"A res.flush method is added to force partially compressed response to be flushed to the client. "},{"title":"React.hydrate()","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#reacthydrate","content":"Same as render(), but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup. "},{"title":"Rehydration","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#rehydration","content":"“booting up” JavaScript views on the client such that they reuse the server-rendered HTML’s DOM tree and data. "},{"title":"ReactDOMServer.renderToNodeStream(element)","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#reactdomserverrendertonodestreamelement","content":"Returns a Readable stream that outputs an HTML string.The HTML output by this stream is exactly equal to what ReactDOMServer.renderToString would return.The function will only work on the server to render HTML as a stream.The client receiving this stream can subsequently call ReactDOM.hydrate() to hydrate the page and make it interactive.  "},{"title":"Streaming SSR","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#streaming-ssr","content":"streaming implies chunks of HTML are streamed from the node server to the client as they are generated.we need to break down each part of the page and send them to client respectivelyoverall process seems like multiple chunks of normal SSRs.can combine with progressive hydration to increase Time to Interactive on client side "},{"title":"Normal SSR (top) v.s. Streaming SSR (bottom)","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#normal-ssr-top-vs-streaming-ssr-bottom","content":" "},{"title":"Pros & Cons","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#pros--cons","content":"pros: Fastest First Contentful Paint, fastest Time to Interactivepros: As the page scales up in content and JS, above the fold load stays constant.pros: More fault tolerant of misbehaving data service further down the page.pros: Streaming enables Node.js server to render multiple requests at the same time and prevents heavier requests from blocking lighter requests for a long time.cons: intra-page code splitting is complicatedcons: webpack doesn't yet support multiple CSS chunks for one entry chunk (2017 video, need to check)cons: tricky to implement perfect optimization of resource loading "},{"title":"Example: GoogleChromeLabs/progressive-rendering-frameworks-samples","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#example-googlechromelabsprogressive-rendering-frameworks-samples","content":"react-streaming-ssr/app/server.js# import React from \"react\"; import ReactDOMServer from \"react-dom/server\"; import App from \"./components/app\"; export default async function ssr({ streaming, ...props }) { if (streaming) { return ReactDOMServer.renderToNodeStream(<App {...props} />); } else { return ReactDOMServer.renderToString(<App {...props} />); } } Copy react-streaming-ssr/server.js# app.get(\"/streaming\", async (request, response) => { try { const stream = await ssr({ url: request.url, }); // Wait until data starts flowing to send a 200 OK, // so errors don't trigger \"headers already sent\". const start = Date.now(); stream.on(\"data\", function handleData() { console.log(\"Render Start: \", Date.now() - start); stream.off(\"data\", handleData); response.useChunkedEncodingByDefault = true; response.writeHead(200, { \"content-type\": \"text/html\", \"content-transfer-encoding\": \"chunked\", \"x-content-type-options\": \"nosniff\", }); response.write(BEFORE); response.flushHeaders(); }); await new Promise((resolve, reject) => { stream.on(\"error\", (err) => { stream.unpipe(response); reject(err); }); stream.on(\"end\", () => { console.log(\"Render End: \", Date.now() - start); response.write(\"</div></body></html>\"); response.end(); resolve(); }); stream.pipe(response, { end: false }); }); } catch (err) { response.writeHead(500, { \"content-type\": \"text/pain\", }); response.end(String((err && err.stack) || err)); return; } }); Copy  "},{"title":"Progressive Hydration","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#progressive-hydration","content":"Purpose: to partially hydrate the content on the client or to prioritize the content that needs to be hydrated.One popular way to achieve this is to wrap your component in the Intersection Observer "},{"title":"Pros","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#pros","content":"Reduce first Time-To-Interact on the client-side.Reduce first paint time on the client-side.Serve content faster to the user without the user noticing any difference. "},{"title":"Example: progressive-hydration","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#example-progressive-hydration","content":"react-progressive-hydration/app/components/hydrator.js export class Hydrator extends React.Component { shouldComponentUpdate() { return false; } componentDidMount() { new IntersectionObserver(async ([entry], obs) => { if (!entry.isIntersecting) return; obs.unobserve(this.root); const { load, ...props } = this.props; const Child = interopDefault(await load()); ReactDOM.hydrate(<Child {...props} />, this.root); }).observe(this.root); } render() { return ( <section ref={(c) => (this.root = c)} dangerouslySetInnerHTML={{ __html: \"\" }} suppressHydrationWarning /> ); } } Copy react-progressive-hydration/app/components/app.js export default function App() { return ( <div id=\"app\"> <Header /> <Intro /> {/* <Stream flush={flushing} /> */} <Hydrator load={load} /> </div> ); } Copy  "},{"title":"Ndoe.js Stream","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#ndoejs-stream","content":"Stream Into the Future (NodeJS Streams) All You Need To Know About Node JS Stream In Detail //TODO "},{"title":"Reference","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#reference","content":"Rendering on the WebStreaming Server-Side RenderingHow Streaming Can Supercharge React - Sasha Aickin aka @xander76 at ReactEurope 2017Stream Into the Future (NodeJS Streams)All You Need To Know About Node JS Stream In Detail "},{"title":"Event Loop","type":0,"sectionRef":"#","url":"web-dev/web-browser-event-loop","content":"","keywords":""},{"title":"What is Event Loop","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#what-is-event-loop","content":"Event loop is a programming construct or design pattern that waits for and dispatches events or messages in a program.Event Loop responsible for scheduling code executions, collecting and processing events, and scheduling queued sub-tasks.One of the important goal of event loop is provide non-blocking I/O operations for single-thread javascript engine.How libuv describe event loop In event-driven programming, an application expresses interest in certain events and respond to them when they occur. The responsibility of gathering events from the operating system or monitoring other sources of events is handled by libuv, and the user can register callbacks to be invoked when an event occurs. The event-loop usually keeps running forever. In pseudocode: e = get the next event if there is a callback associated with e: call the callback Copy Event loop in browser or Node.js is not part of the JS Engine (runtime). "},{"title":"Concurrency Model and Event Loop","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#concurrency-model-and-event-loop","content":""},{"title":"in Browser(Chrome)","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#in-browserchrome","content":" "},{"title":"in Node.js","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#in-nodejs","content":" While Nodejs uses the Google V8 as it's runtime, it does not used V8 to implement the event loop.Nodejs uses the Libuv library (written in C) to implement the event loop. "},{"title":"Terms: of architecture & concept","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#terms-of-architecture--concept","content":""},{"title":"libuv","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#libuv","content":"libuv is a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js libuv enforces an asynchronous, event-driven style of programming. Its core job is to provide an event loop and callback based notifications of I/O and other activities. libuv offers core utilities like timers, non-blocking networking support, asynchronous file system access, child processes and more. ref: Basics of libuv "},{"title":"I/O","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#io","content":"Short for input/output, I/O refers primarily to the program’s interaction with the system’s disk and network.Examples of I/O operations include reading/writing data from/to a disk, making HTTP requests, and talking to databases.I/Os are very slow compared to accessing RAM or doing work on the CPU. "},{"title":"Blocking v.s. Non-Blocking","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#blocking-vs-non-blocking","content":"Blocking is when the execution of additional JavaScript in the Node.js process must wait until a non-JavaScript operation completes.Blocking happens because the event loop is unable to continue running JavaScript while a blocking operation is occurring.In Node.js, non-blocking primarily refers to I/O operationsAll of the I/O methods in the Node.js standard library provide async versions.Blocking methods execute synchronously and non-blocking methods execute asynchronously. "},{"title":"Events and event-driven programming","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#events-and-event-driven-programming","content":"Events are actions generated by the user or the system, like a click, a completed file download, or a hardware or software error.Event-driven programming is a programming paradigm in which the flow of the program is determined by events.An event-driven program performs actions in response to events. When an event occurs it triggers a callback function. "},{"title":"Thread Pool & Is Node.js Single Thread?","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#thread-pool--is-nodejs-single-thread","content":"Javascript Engine, Javascript code was single-thread.I/Os, file system operations are multi-threaded.libuv / Node.js provides a threadpool of default size 4.New updates of Node.js offers workerpool to create threads easily. const crypto = require(\"crypto\"); const start = Date.now(); function logHashTime() { crypto.pbkdf2(\"a\", \"b\", 100000, 512, \"sha512\", () => { console.log(\"Hash: \", Date.now() - start); }); } // default size of thread pool is 4 // first 4 will be execute in parallel (almost same time) logHashTime(); logHashTime(); logHashTime(); logHashTime(); // 5th one will be execute later. logHashTime(); Copy ref: Node.js multithreading: What are Worker threads, and why do they matter?  "},{"title":"Terms of Tasks","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#terms-of-tasks","content":"Priority of execution Sync > Nanotask > Microtask > Task / Macrotask Note: nanotask only exists in Node.js "},{"title":"Task ( = Macrotask)","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#task---macrotask","content":"Generic task sources# DOM manipulation/parsingUser Interaction: keyboard or mouse inputNetwork activity: fetch, XMLHttpRequesthistory traversal: history.back()Web APIs: setTimeout, setInterval, setImmediate(legacy), requestAnimationFrame, I/O, UI rendering "},{"title":"Microtask","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#microtask","content":"microtask is a short function which is executed after the function or program which created it exits and only if the JavaScript execution stack is empty, but before returning control to the event loop being used by the user agent to drive the script's execution environment.microtasks can queue other microtasks, while there are microtasks in the microtask queue, they should all be run one by one until the microtask queue is empty. Example of Microtask# Promise, Promise.thenprocess.nextTickObject.observe "},{"title":"Tick","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#tick","content":"a complete process of one event loop including: dequeuing of an event from the event loop queuethe execution of said event.  "},{"title":"Event Loop in Node.js","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#event-loop-in-nodejs","content":"macrotask should be processed from the macrotask queue in one tick of the event loop. After this macrotask has finished, all other available microtasks should be processed within the same tick.  ┌───────────────────────────┐ ┌─>│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │<─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ Copy //TODO  "},{"title":"Reference","type":1,"pageTitle":"Event Loop","url":"web-dev/web-browser-event-loop#reference","content":"Using microtasks in JavaScript with queueMicrotask() Node.js Under The Hood #3 - Deep Dive Into the Event Loop Node.js: Overview of Blocking vs Non-Blocking libuv: Basics of libuv Node.js: what it is, when and how to use it, and why you should MDN: Concurrency model and the event loop PJChenDer: [Note] Event loop, micro-task, macro-task, async JavaScript 筆記 我知道你懂 Event Loop，但你了解到多深？ 【筆記】到底 Event Loop 關我啥事？ "},{"title":"Browser Navigation Flow","type":0,"sectionRef":"#","url":"web-dev/web-browser-navigation-flow","content":"","keywords":""},{"title":"Review Browser Architecture","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#review-browser-architecture","content":" "},{"title":"Browser Process","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#browser-process","content":"consists of# UI threadnetwork thread control# Chrome part of the application including address bar, bookmarks, back and forward buttons. "},{"title":"Renderer Process","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#renderer-process","content":"consists of# Main threadworker thread control# anything inside of the tab where a website is displayed. "},{"title":"GPU Process(s)","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#gpu-processs","content":"Control# Handles GPU tasks in isolation from other processes. "},{"title":"Reference","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#reference","content":"Which process controls what?  "},{"title":"What happens when we visit google.com?","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#what-happens-when-we-visit-googlecom","content":""},{"title":"W3C 5.1 Processing Model","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#w3c-51-processing-model","content":"This illustration is non-normative. The following graph illustrates the timing attributes defined by the PerformanceTiming interface and the PerformanceNavigation interface with or without redirect, respectively. Attributes underlined may not be available in navigation involving documents from different origins. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.  "},{"title":"Browser process: Handling Input","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#browser-process-handling-input","content":"Handling Input: UI thread needs to parse and decide whether to send you to a search engine, or to the site you requested.Start navigation:UI thread initiates a network call to get site content.DNS Lookup: network thread initiates DNS lookup. "},{"title":"DNS lookup","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#dns-lookup","content":"Check Cache: Browser check browser’s local cache and computer's DNS cache if there is already IP address saved.If No Cache, the query travels into the Internet and is received by a DNS recursive resolver.The resolver then queries a DNS root nameserver (.).The root server then responds to the resolver with the address of a Top Level Domain (TLD) DNS server (such as .com or .net), which stores the information for its domains. When searching for example.com, our request is pointed toward the .com TLD.The resolver then makes a request to the .com TLD.The TLD server then responds with the IP address of the domain’s nameserver, example.com.Lastly, the recursive resolver sends a query to the domain’s nameserver.The IP address for example.com is then returned to the resolver from the nameserver.The DNS resolver then responds to the web browser with the IP address of the domain requested initially. "},{"title":"Network Thread: Make Request","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#network-thread-make-request","content":"Once the 8 steps of the DNS lookup have returned the IP address for example.com, the browser is able to make the request for the web page: Browser setup TCP connection to the server via a TCP three-way handshake. For HTTPS connection, another TLS Handshake is required Browser sends an initial HTTP GET request to the IP address.Server send HTTP response with meta info in header to Browser.Browser receives the response header and content. #Time to First ByteBrowser check Content-Type header to determine the type of data. if Content-Type header is missing or wrong, MIME Type sniffing is done here. Browser stores cookie, and make request for css or jsNetwork Thread tells UI thread that the data is ready.UI thread finds a renderer process to continue rendering. Meanwhile UI thread updates the UI of browser (ex. url bar, security indicator)The session history for the tab will be updated "},{"title":"Renderer Process: Rendering","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#renderer-process-rendering","content":"check detail about Critical Rendering Path Img: Navigation Timing API#  Img: Rendering Process#  domLoading event: main thread Parse HTML and Construct DOM tree.Download resource: such as images, CSS, and JavaScript preload scanner sends requests to the network thread.JavaScript compilation: JavaScript is interpreted, compiled, parsed and executed. The scripts are parsed into abstract syntax trees domInteractive event: DOM tree is constructed.main thread Parse CSS, Calculate style to Construct CSSOM tree/computed styledomContentLoaded: DOM tree and CSSOM tree both constructed. Normally Javascript start executing on this event. main thread going over DOM tree with computed styles and producing layout treemain thread walks the layout tree to create paint records Paint record is a note of painting process like \"background first, then text, then rectangle\". "},{"title":"Paint","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#paint","content":""},{"title":"Compositing","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#compositing","content":"because sections of the document are drawn in different layerslayer tree is created and paint orders are determinedmain thread commits that information to the compositor threadThe compositor thread then rasterizes each layer. A layer could be large like the entire length of a page, so the compositor thread divides them into tiles and sends each tile off to raster threads.Raster threads rasterize each tile and store them in GPU memory. "},{"title":"Reflow","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#reflow","content":"As the page continues to load assets, reflows can happenA reflow sparks a repaint and a re-composite.  "},{"title":"Service Worker","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#service-worker","content":"TBC... "},{"title":"Reference","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#reference-1","content":"W3C: navigation timingInside look at modern web browser (part 2)Inside look at modern web browser (part 3)What Is DNS? | How DNS WorksCritical Rendering Path使用 Navigation Timing 評估關鍵轉譯路徑MDN: how browsers work "},{"title":"JS engine: Introduction","type":0,"sectionRef":"#","url":"web-dev/web-js-engine-introduction","content":"","keywords":""},{"title":"Main Javascript Engines","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#main-javascript-engines","content":"Chrome/Google: V8FireFox/Mozilla: SpiderMonkeyEdge/Microsoft: used to be Chakra / now v8Safari/Apple: JavaScriptCore "},{"title":"Javasciprt Engine Pipeline","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#javasciprt-engine-pipeline","content":" JS Engines runs with this similiar pipeline but different in optimization process. "},{"title":"Process","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#process","content":"parse javascript into Abstract Syntax Tree (AST)interpreter generate byte codeOptimization start!bytecode is sent to the optimizing compiler along with profiling data.optimizing compiler makes assumption then produces highly-optimized machine code based on profiling dataIf the assumptions turns out to be incorrect, the optimizing compiler deoptimizes and goes back to the interpreter. "},{"title":"Trade off","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#trade-off","content":""},{"title":"Startup Speed","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#startup-speed","content":" interpreter: produce bytecode quickly, produces inefficient machine code.optimizing compiler: takes longer, produces efficient machine code. "},{"title":"Memory","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#memory","content":" optimized machine code also requires more memory. "},{"title":"Note","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#note","content":"Initialize object props with sensible values.always initialize objecs in the same way.type checking is about developer productivity but not about engine performance "},{"title":"Reference","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#reference","content":"JavaScript engine fundamentals: optimizing prototypesJavaScript engine fundamentals: Shapes and Inline CachesMathias B, Benedikt M - JS Engine fundamentals [AgentConf] "},{"title":"JS engine: Optimizing of Object","type":0,"sectionRef":"#","url":"web-dev/web-js-engine-object-optimization","content":"","keywords":""},{"title":"TL;DR","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#tldr","content":"Javascript objects are dictionaries essentially, but engines use Shape internally to optimize it.Prototypes are just objects, but Javascript Engine treate them specially.Do not mess with Prototypes, it hurts performance because the. "},{"title":"JavaScript’s object model","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#javascripts-object-model","content":""},{"title":"How JavaScript defines objects.","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#how-javascript-defines-objects","content":" The ECMAScript specification essentially defines all objects as dictionaries, with string keys mapping to property attributes. [[Writable]]: whether the property can be reassigned to. [[Enumerable]]: whether the property shows up in for-in loops. [[Configurable]]:whether the property can be deleted. We can see these properties with const object = { foo: 42 }; Object.getOwnPropertyDescriptor(object, \"foo\"); // → { value: 42, writable: true, enumerable: true, configurable: true } Copy  "},{"title":"How are these these property attributes actually stored in memory?","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#how-are-these-these-property-attributes-actually-stored-in-memory","content":""},{"title":"Shape as Optimization","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#shape-as-optimization","content":"If we assume that we’ll be seeing more objects with this shape later, then it’s wasteful to store the full dictionary containing the property names and attributes on the JSObject itself, as the property names are repeated for all objects with the same shape. That’s a lot of duplication and unnecessarily memory usage. As an optimization, engines store the Shape of the object separately. No matter how many objects there are, as long as they have the same shape, we only have to store the shape and property information once!  This Shape contains all the property names and the attributes, except for their [[Value]]s.Every JSObject with this same shape points to exactly this Shape instance.Offset: record the offset of the values inside of the JSObject so JavaScript engine knows where to find the values. "},{"title":"Naming","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#naming","content":"All JavaScript engines use shapes as an optimization, but they don’t all call them shapes.Academic papers: Hidden Classes (confusing w.r.t. JavaScript classes)V8: Maps (confusing w.r.t. JavaScript Maps)Chakra: Types (confusing w.r.t. JavaScript’s dynamic types and typeof)JavaScriptCore:StructuresSpiderMonkey:Shapes  "},{"title":"What happens if you have an object with a certain shape, but then you add a property to it?","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#what-happens-if-you-have-an-object-with-a-certain-shape-but-then-you-add-a-property-to-it","content":""},{"title":"Transition Chain","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#transition-chain","content":"The shapes form so-called transition chains in the JavaScript engine. const object = {}; object.x = 5; object.y = 6; Copy  Transition Chains are link list, every Shape links back to its previous shape.Every time we add new properties in Object, JavaScript engine transitions to a new shape which only needs to know about the new property it introduces. In this case the Shape(x,y) pointThe order in which properties are added impacts the shape. For example, { x: 4, y: 5 } results in a different shape than { y: 5, x: 4 }  "},{"title":"Inline Caches (ICs)","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#inline-caches-ics","content":"ICs: memorize information on where to find properties on objects, to reduce the number of expensive lookups.ICs are the key ingredient to making JavaScript run fast! "},{"title":"Note","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#note","content":"Initialize object props with sensible values.always initialize objecs in the same way.type checking is about developer productivity but not about engine performance "},{"title":"Reference","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#reference","content":"JavaScript engine fundamentals: optimizing prototypesJavaScript engine fundamentals: Shapes and Inline CachesMathias B, Benedikt M - JS Engine fundamentals [AgentConf]The story of a V8 performance cliff in React "},{"title":"Lighthouse Performance","type":0,"sectionRef":"#","url":"web-dev/web-lighthouse-performance","content":"","keywords":""},{"title":"前言","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#前言","content":"如何定義一個好的網頁？LightHouse下的網頁評分標準有四項： PerformanceBest PracticesSEOAccessibility 本次紀錄主要探討 Performance 部分。 "},{"title":"效能測試工具","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#效能測試工具","content":"PageSpeed Insights只會測 Performance 相關 issue。 GTmetrix Chrome Devtool Performance 可以直接在 Browser 上測。 "},{"title":"原理","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#原理","content":""},{"title":"Critical Rendering Path","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#critical-rendering-path","content":"Download Resource#  第一次往返: 傳輸 html。第二次-第 N 次往返: 傳輸 CSS 和 JS。 Rendering Process#  頁面要等到 DOM 和 CSSOM 都解析完後，才會 render 出畫面。 名詞解釋# 關鍵資源/禁止轉譯資源：可能禁止網頁初次轉譯的資源。 CSS 預設為禁止轉譯(render blocking)，也就是 CSSOM 還未建構完成前，瀏覽器不會進行轉譯。「禁止轉譯」僅指該資源是否會阻止瀏覽器初次轉譯網頁。無論是否禁止，瀏覽器仍會下載 CSS，只是優先順序較低。 關鍵路徑長度：即往返過程數量，或擷取所有關鍵資源所需的總時間。關鍵位元組：實現網頁初次轉譯所需的總位元組數，這是所有關鍵資源的傳輸檔案大小總和。  "},{"title":"優化實作","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#優化實作","content":""},{"title":"優化方向 - PRPL pattern","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#優化方向---prpl-pattern","content":"Push (or preload) the most important resources.Render the initial route as soon as possible.Pre-cache remaining assets.Lazy load other routes and non-critical assets. "},{"title":"CSS 優化","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#css-優化","content":"定義: CSS 預設為禁止轉譯，也就是 CSSOM 還未建構完成前，瀏覽器不會進行轉譯。效能: 過多的禁止轉譯 CSS 會影響 FCP, TTI 等效能指數。優化: inline/preload critical CSSdefer non-critical CSS <link rel=\"preload\" as=\"style\" href=\"async_style.css\" onload=\"this.rel='stylesheet'\" /> <noscript><link rel=\"stylesheet\" href=\"[yourcssfile]\" /></noscript> Copy CSS import 會增加往返次數/影響效能 "},{"title":"JS 優化","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#js-優化","content":"原則: 若首次載入時沒有需要 JS 才能顯示的部分，則 JS 理論上不影響 FCP。過去: JS 若在 DOM 解析完成前執行，會阻擋 DOM 解析，因此基本上放 body 最後。現行: 使用defer和async延遲載入 JS，可以直接放headerSPA: 首次渲染慢，因為還要等 JS 解析完，但可以從減少 bundle 大小優化，也就是 Code-Splitting。 "},{"title":"Preload","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#preload","content":"原先 Browser 有內建的資源優先等級，使用 preload，更進一步設定載入優先順序可套用對象: CSS/JS/Font使用情境: CSS, 和牽涉到關鍵路徑的 JS 等重要資源\bprelod: 標示資源為高優先順序ref: [ <link rel=\"preload\" as=\"script\" href=\"super-important.js\" /> <link rel=\"preload\" as=\"style\" href=\"critical.css\" /> <link rel=\"preload\" as=\"font\" crossorigin=\"anonymous\" type=\"font/woff2\" href=\"myfont.woff2\" /> Copy "},{"title":"圖片 Lazy-Loading","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#圖片-lazy-loading","content":"with HTML (Can I use loading-lazy-attr) <img src=\"my-image.jpg\" loading=\"lazy\" /> Copy with JS (IntersectionObserver) 不讓圖片正常載入監視圖片元素，判斷它們是否進入到畫面中元素進入畫面後，再載入圖片範例 1: Lazy loading images using IntersectionObserver - example code範例 2: Lazy Loading background images in CSS  "},{"title":"Performance 指標","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#performance-指標","content":"based on Lighthouse V6  "},{"title":"FCP (First Contentful Paint) 首次內容繪製","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#fcp-first-contentful-paint-首次內容繪製","content":"當瀏覽者到達網站之後，首次顯示 DOM 內容需要的時間。FCP = TTFB(Time to First Byte) + Content Load Time + Render Time優化方法: 降低 TTFB: Hosting Provider, CDN, cache移除阻擋渲染的資源: Inline Critical Resources, Defer Non-Critical Resources, Remove Anything Unused將 Critical Path 的 CSS 做 inline首次渲染的圖片不要做 Lazy Loadinginline-SVG降低 DOM-tree 大小: 僅在需要時創建 node，銷毀不需要的 node，不要用 CSS 隱藏 / 不要過多層的div確保在字體 loading 完成之前文字仍可見: font-face, CDN:＆display = swap使用 Resource Hint: prerender , preload, prefetch, preconnect避免 Redirect ref:10 Proven Ways To Improve First Contentful Paint (FCP) in WordPress "},{"title":"SI (Speed Index) 速度指數","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#si-speed-index-速度指數","content":"速度指數會以「網頁可見內容填入速度」計算，也就是以眼睛可以看到的圖像去計算分數。因素: html+CSS Frame[i] = interval time*(1 – visual complete %/100) SI score = Frame[1]+...+Frame[n] Copy ref: Understanding Speed Index "},{"title":"TTI (Time to Interactive) 可互動時間","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#tti-time-to-interactive-可互動時間","content":"「網頁進入完整互動狀態前」花費的時間，簡單來說網站要全部載入才能開始閱讀、互動。因素: HTML+CSS+圖片+JavaScript "},{"title":"LCP (Largest Contentful Paint) 最大內容繪製","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#lcp-largest-contentful-paint-最大內容繪製","content":"最大的文字、圖片或是影片呈現到眼前所需要的時間。因素: 文字+圖片 "},{"title":"CLS (Cumulative Layout Shift) 累計版面配置轉移","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#cls-cumulative-layout-shift-累計版面配置轉移","content":"測量可見元素在可視區域內的移動情形，當網站讀取過慢，正要點的時候按鈕(物件)忽然跑掉造成點錯位置，越少越好。常見原因: 沒有圖框包圍的圖像沒有尺寸的廣告或嵌入式 iframe動態注入的內容 "},{"title":"TBT (Total Blocking Time) 封鎖時間總計","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#tbt-total-blocking-time-封鎖時間總計","content":"當工作長度超過 50 毫秒時，從 FCP 到 TTI 之間，準備時間的時間範圍總計，延遲越久分數越低。因素:FCP、TTI、SI。 "},{"title":"FID (First Input Delay 首次輸入延遲","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#fid-first-input-delay-首次輸入延遲","content":"測量互動性的速度，為了提供良好的用戶體驗，網頁的 FID 應當小於 100 毫秒，像是點擊(Click)。無論是點擊連結、影片、圖片，只要點下去反應很慢的，慢到以為網站故障、無作用，就是「首次輸入的延遲」。  "},{"title":"Reference","type":1,"pageTitle":"Lighthouse Performance","url":"web-dev/web-lighthouse-performance#reference","content":"分析關鍵轉譯路徑效能禁止轉譯的 CSSApply instant loading with the PRPL pattern[教學] 深入淺出 Preload, Prefetch 和 Preconnect：三種加快網頁載入速度的 Resource Hint 技巧10 Proven Ways To Improve First Contentful Paint (FCP) in WordPressUnderstanding Speed IndexWeb - Timeline of a page load (Page Speed|Page Latency) "},{"title":"Webpack Overview","type":0,"sectionRef":"#","url":"web-dev/webpack-overview","content":"","keywords":""},{"title":"Concepts","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#concepts","content":"Everything is a module (including, js, css, images, html) "},{"title":"Entry","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#entry","content":"the starting file to build dependency graph "},{"title":"Output","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#output","content":"where to emit the bundles it creates and how to name these files "},{"title":"Loader","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#loader","content":"Loaders are transformations that are applied to the source code of a module. Loaders work at the individual file level during or before the bundle is generated.Loaders allow you to pre-process files as you import or load them E.g.# babel-loader: Converts ES6+ JavaScript to ES5 using Babel.css-loader: Loads .css files to be used by other loaders. "},{"title":"Plugin","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#plugin","content":"A webpack plugin is a JavaScript object that has an apply method. This apply method is called by the webpack compiler, giving access to the entire compilation lifecycle.Plugins work at bundle or chunk level and usually work at the end of the bundle generation process. Plugins can also modify how the bundles themselves are created.  const pluginName = 'ConsoleLogOnBuildWebpackPlugin'; class ConsoleLogOnBuildWebpackPlugin { apply(compiler) { //accessing tap lifecycle compiler.hooks.run.tap(pluginName, (compilation) => { console.log('The webpack build process is starting!!!'); }); } } module.exports = ConsoleLogOnBuildWebpackPlugin; Copy Example: CSSO Webpack Plugin#  Plugins# terser-webpack-plugin: for Javascript minifyingmini-css-extract-plugin: for separating CSS into CSS file per JS file.  "},{"title":"Example: Bundling a static site","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#example-bundling-a-static-site","content":" In this case the plugins are only used for production. "},{"title":"webpack.config.js","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#webpackconfigjs","content":"Since webpack v4 the extract-text-webpack-plugin should not be used for css. Use mini-css-extract-plugin instead.babel-preset-es2015 -> babel-preset-envWebpack v5 comes with the latest terser-webpack-plugin out of the box. const path = require('path'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { entry: './src/main.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-react', '@babel/preset-env'] } } }, { test: /\\.css$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', // postcss-loader should load before css-loader { loader: 'postcss-loader', options: { // pass autoprefixer plugin plugins: [require('autoprefixer')], }, }, ], }, ], }, plugins: [new MiniCssExtractPlugin()], // terser-webpack-plugin config before webpack v4 minimizer: [ new TerserPlugin({ terserOptions: { mangle: { compress: {}, }, } }) ] }; Copy  "},{"title":"Development (webpack-dev-server + Hot Module Replacement)","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#development-webpack-dev-server--hot-module-replacement","content":"Webpack injects a whole lot of JS libraries to make HMR work.   Some file changed Webpack uses HotModuleReplacementPlugin to generate a manifest(a JSON containing list of changed modules) and an update file(a JS with the actual change info). Webpack then tells webpack-dev-server about the changes webpack-dev-server tells webpack-dev-server/client running in the browser via web socket by sending invalid notification via web socket. webpack-dev-server/client then sends the initial hash (e.g. b2e2d54372f42c1b2352) that it got when the app was first loaded to hot/dev-server library. hot/dev-server acts like the main interface to all other JS files. hot/dev-server then calls internal libraries(like JSONP runtime) that are also injected by Webpack to download the manifest file. JSONP runtime uses hash and loads the manifest file from the webpack-dev-server. The manifest file contains details about chunks that need to be uploaded to the browser. It’s file name looks like: b2e2d54372f42c1b2352.hot-update.json and it’s content looks like this: {“h”:”b3632c2a800d437e17df”,”c”:[0]} JSONP runtime then uses information contained inside the manifest file to load all the update chunks and adds them to the DOM. Updates JS themselves are JS files. They contain information about actual changes that needs to be applied. They are added to the DOM and executed. Updates call HMR runtime with the module id (e.g. moduleId 82 in the above example) and the actual changes. But HMR runtime itself doesn’t know how to deal with the changes. So it delegates this job to corresponding loaders like react-hot-loader runtimes or style-loader runtimes to apply changes. ( Note that these are also injected into the Browser. If there is no issues with applying the changes, the appropriate runtimes updates the module. If there are issues (like syntax errors in the change), hot/dev-server lib is notified about the error. "},{"title":"Reference","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#reference","content":"Anatomy of a Static SiteAnalysis of Webpack HMR PrincipleWebpack & The Hot Module Replacement "},{"title":"HTTP Methods","type":0,"sectionRef":"#","url":"web-fundamental/http-methods","content":"","keywords":""},{"title":"GET","type":1,"pageTitle":"HTTP Methods","url":"web-fundamental/http-methods#get","content":"idempotentpass data only in paramSAFECache: cache-ableremain in the browser historyhas length restrictions "},{"title":"POST","type":1,"pageTitle":"HTTP Methods","url":"web-fundamental/http-methods#post","content":"non-idempotentpass the data in bodynot SAFECache: not cache-able, unless the response includes appropriate Cache-Control or Expires header fields. "},{"title":"Cache Control","type":0,"sectionRef":"#","url":"web-fundamental/web-cache-control","content":"","keywords":""},{"title":"Response Header","type":1,"pageTitle":"Cache Control","url":"web-fundamental/web-cache-control#response-header","content":"Cache-Control: The server can return a Cache-Control directive to specify how, and for how long, the browser and other intermediate caches should cache the individual response.ETag: When the browser finds an expired cached response, it can send a small token (usually a hash of the file's contents) to the server to check if the file has changed. If the server returns the same token, then the file is the same, and there's no need to re-download it.Last-ModifiedThis header serves the same purpose as ETag, but uses a time-based strategy to determine if a resource has changed, as opposed to the content-based strategy of ETag. //TODO //TODO "},{"title":"Reference","type":1,"pageTitle":"Cache Control","url":"web-fundamental/web-cache-control#reference","content":"Prevent unnecessary network requests with the HTTP Cache "},{"title":"CORS","type":0,"sectionRef":"#","url":"web-fundamental/web-cors","content":"","keywords":""},{"title":"基礎","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#基礎","content":"Same Origin 的限制比 Cookie 限制嚴格，基本上只有網址前面完全相同，才會算 same origin。CORS 是 browser 基於安全性考量而做的限制，非 browser (ex. Postman) 則不會遇到。在<image>, <script> 載入資源，因為 response 會直接印在 html 上，Javascript 無法讀取到，所以可以載入 Cross Origin 的資源。Access-Control-Allow-Origin 只能加一個網域 或 * (全部)解決方法 1: 若對後端沒有掌控權，可以自架 proxy server "},{"title":"簡單請求(simple request)","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#簡單請求simple-request","content":"來自: 符合以下兩個條件的 request Request method is: HEAD, GET, POSTContent-Type of POST is: text/plain, multipart/form-data, application/x-www-form-urlencoded 成功條件: 後端只要加上適當的 Access-Control-Allow-Origin header 即可成功。 res.header(\"Access-Control-Allow-Origin\", VALID_ORIGIN); Copy "},{"title":"非簡單請求(not-so-simple request)","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#非簡單請求not-so-simple-request","content":"來自: 簡單請求以外的情況。會有兩筆 request: 正式 request 之前，會多一次 Preflight Request。成功條件: 見 Preflight Request res.header(\"Access-Control-Allow-Origin\", VALID_ORIGIN); res.header(\"Access-Control-Allow-Headers\", \"content-type\"); Copy "},{"title":"Preflight Request","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#preflight-request","content":"目的: 為了避免陳年的後端收到預期外的請求，瀏覽器先詢問伺服器，當前網頁所在的域名是否在伺服器的許可名單之中，以及可以使用哪些 HTTP 動詞和頭資訊欄位。 成功條件: 後端需要設定 Access-Control-Allow-Origin header 需列出允許的 origin 或 *。Access-Control-Allow-Headers header 需列出允許哪些請求的 headers。最常見是 Content-Type，如果有其他發送的自訂 header ，也須列在其中。 用 Javascript 處理圖片會遇到Allowing cross-origin use of images and canvas問題 如果 preflight 沒有通過，是不會發出正式的 request "},{"title":"非簡單請求 + 帶 Cookie","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#非簡單請求--帶-cookie","content":"成功條件: 後端需要設定 Access-Control-Allow-Origin header 需要明確指定，不能為*Access-Control-Allow-Headers header 需列出允許哪些請求的 headers。Access-Control-Allow-Credentials,header 須為 true 前端需要設定 fetch 加上 credentials: include res.header(\"Access-Control-Allow-Origin\", VALID_ORIGIN); // 明確指定 res.header(\"Access-Control-Allow-Credentials\", true); res.header(\"Access-Control-Allow-Headers\", \"content-type, X-App-Version\"); Copy "},{"title":"Extras","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#extras","content":"如前端需要拿到自定義 header，後端就需要帶上 Access-Control-Expose-Headers: \"CUSTOM_HEADER\"GET、HEAD 以及 POST 以外的 HTTP method 發送請求的話，後端的 preflight response header 必須有 Access-Control-Allow-Methods 並且指定合法的 method，preflight 才會通過，瀏覽器才會把真正的 request 發送出去。需要快取的話 Access-Control-Max-Age "},{"title":"Reference","type":1,"pageTitle":"CORS","url":"web-fundamental/web-cors#reference","content":"CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ "},{"title":"Web Security","type":0,"sectionRef":"#","url":"web-fundamental/web-security","content":"","keywords":""},{"title":"Common Web Applications Attacks","type":1,"pageTitle":"Web Security","url":"web-fundamental/web-security#common-web-applications-attacks","content":""},{"title":"Cross-Site Scripting (XSS)","type":1,"pageTitle":"Web Security","url":"web-fundamental/web-security#cross-site-scripting-xss","content":"常見種類# Stored XSS 藉由 DB 中的 Javascritpt 程式碼攻擊，程式碼可能透過留言板、部落格等輸入方式，將帶有攻擊指令碼的內容存至資料庫中，被當成一般的 HTML 執行。Reflected XSS 非儲存在 DB 中、前端直接傳送帶有攻擊指令的內容至伺服器。例如以 GET 方式傳送 request 至伺服器時，伺服器未檢查直接回傳資料至網站中。DOM Based XSS 指網頁上的 JavaScript 在執行過程中，沒有檢查資料使得操作 DOM 的過程植入了攻擊指令。(通常是因為 JS 使用 innerHTML()) 如何防範# 1 和 2 由後端防範：需檢查 HTML 程式碼與使用者輸入的內容，刪除< script >等帶有指令的文字。3 由前端防範：避免在 html 內寫 JS/避免使用 innerHTML()來更換網頁內容。3 由後端防範：Content Security Policy 避免開啟 'unsafe-inline' "},{"title":"SQL Injection","type":1,"pageTitle":"Web Security","url":"web-fundamental/web-security#sql-injection","content":"是在輸入的字串之中夾帶 SQL 指令，在設計不良的程式當中忽略了字元檢查，那麼這些夾帶進去的惡意指令就會被資料庫伺服器誤認為是正常的 SQL 指令而執行，因此遭到破壞或是入侵。 常見種類# Authorization Bypass \"SELECT * FROM customers WHERE name =' -name- ' AND password = ' -password-' Copy input name = 'OR 1=1 -- Copy \"SELECT * FROM customers WHERE name =''OR 1=1 Copy 如何防範# 使用 Regular expression 驗證過濾輸入值與參數中惡意代碼，將輸入值中的單引號置換為雙引號。限制輸入字元格式並檢查輸入長度。資料庫設定使用者帳號權限，限制某些管道使用者無法作資料庫存取。 "},{"title":"Distributed Denial of Service (DDoS)","type":1,"pageTitle":"Web Security","url":"web-fundamental/web-security#distributed-denial-of-service-ddos","content":"使用一台以上的機器向目標發送惡意流量，利用大量網際網路流量淹沒目標伺服器、服務或網路，破壞它們的正常運作。壓力測試工具也可以當作攻擊的工具。 常見種類# HTTP 洪水攻擊，透過 HTTP GET 和 POST 要求淹沒目標 (ex. High Orbit Ion Cannon (HOIC))利用 UDP 等通訊協定向目標伺服器傳送大量流量(ex.Low Orbit Ion Cannon (LOIC)) 如何防禦# 限速：限制伺服器在特定時間範圍內接受的要求數量Web 應用程式防火牆：使用工具來基於一系列規則篩選 Web 流量Anycast 網路擴散：在伺服器和傳入流量之間置入一個分散式雲端網路，以提供額外的運算資源來回應要求。 "},{"title":"Clickjacking","type":1,"pageTitle":"Web Security","url":"web-fundamental/web-security#clickjacking","content":"攻擊方式# 利用網頁的 iFrame 將假造的網頁與正常的網頁載入，在透過 iframe visibility 的屬性設定，將正常網站的網頁(如：銀行網頁)隱藏，讓使用者看到是一個假造的網頁(如：中獎通知)。當使用者輸入帳號密碼時，其實背後是登入實際的網站。駭客因此藉接獲取該銀行的帳號密碼與存取權限。 如何防禦# server response 設定 header X-Frame-Options: SAMEORIGIN / DENY / ALLOW-FROM 來指示文件是否能夠載入 <frame> header(\"X-Frame-Options: SAMEORIGIN\"); Copy server response 設定 header CSP: frame-ancestors Content-Security-Policy: frame-ancestors 'none'; Content-Security-Policy: frame-ancestors 'self' https://www.example.org; Copy X-Frame-Options v.s. CSP: frame-ancestors# The major difference is that many user agents implement SAMEORIGIN such that it only matches against the top-level document’s location. This directive checks each ancestor. "},{"title":"CSRF","type":1,"pageTitle":"Web Security","url":"web-fundamental/web-security#csrf","content":"攻擊方式# 假設使用者曾經登入過 example.com 並取得 Cookie，當使用者瀏覽惡意網站 evil.com 時，網站中的 JavaScript 可以對 example.com/pay?amount=1000 發出 POST Request，瀏覽器會自動帶上 example.com 的 Cookie。 防禦方式# server 端檢查 Referer 是否為合法 domain const referer = request.headers.referer; Copy server 端每次請求生成 CSRF token，並回傳給前端，並驗證每次的 submit，不合 token 的並無法 <form action=\"https://example.com/pay\" method=\"POST\"> <input type=\"hidden\" name=\"amount\" value=\"1000\" /> <input type=\"hidden\" name=\"csrftoken\" value=\"someRandomToken\" /> <button type=\"submit\" /> </form> Copy SameSite: server 端 cookie header 設定 SameSite，可以使用 Strict 或 Lax 將 Cookie 限制為同一站點請求。SameSite cookies explained "}]