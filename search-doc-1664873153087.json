[{"title":"Hello","type":0,"sectionRef":"#","url":"blog/hello-world","content":"Welcome to this blog. This blog is created with Docusaurus 2 alpha. This is a test post. A whole bunch of other information.","keywords":""},{"title":"Infra Engineer 雜感","type":0,"sectionRef":"#","url":"blog/infra","content":"","keywords":""},{"title":"優點","type":1,"pageTitle":"Infra Engineer 雜感","url":"blog/infra#優點","content":"比較不用跟PM打交道，開會次數比較少，專注在工程面。Infra Team通常會有熱愛工程的大神，Staff Engineer比例也較高，可以與之學習。自由度高，可以接觸到不同Programming Language。 "},{"title":"缺點","type":1,"pageTitle":"Infra Engineer 雜感","url":"blog/infra#缺點","content":"可能要on call，壓力大。跳槽新創機會比Application Engineer低一點，而且recruiter通常不知道你在幹嘛。需要閱讀大量文件，學習週期長，需要有耐心撐過。 "},{"title":"Ref","type":1,"pageTitle":"Infra Engineer 雜感","url":"blog/infra#ref","content":"軟體工程師的修煉與成長 (4) — Product vs Infrastructure讨论：继续做infra还是做product？哪个更有前（钱）途？ "},{"title":"Welcome","type":0,"sectionRef":"#","url":"blog/welcome","content":"Blog features are powered by the blog plugin. Simply add files to the blog directory. It supports tags as well! Delete the whole directory if you don't want the blog features. As simple as that!","keywords":""},{"title":"474. Ones and Zeroes","type":0,"sectionRef":"#","url":"algorithm/leetcode-474-ones-and-zeroes","content":"","keywords":""},{"title":"Problem","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#problem","content":"You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0's and* n 1 's in the subset. A set x is a subset of a set y if all elements of x are also elements of y. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4. Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}. {\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3. Copy Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: The largest subset is {\"0\", \"1\"}, so the answer is 2. Copy Constraints: 1 <= strs.length <= 6001 <= strs[i].length <= 100strs[i] consists only of digits '0' and '1'.1 <= m, n <= 100 "},{"title":"Explanation","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#explanation","content":""},{"title":"Identify Problem","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#identify-problem","content":"This is a 0/1 knapsack problem with 2 constraints. The value of items ( total count ) are equal. "},{"title":"DP matrix:","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#dp-matrix","content":"we have dp[i][j][k]: the max number of strings that can be formed with i 0's and j 1 's i is count of zeroj is count of onek is the index of element Since we need maximum so the k-axis can be flattened. Then we have dp[i][j] "},{"title":"Transition Function","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#transition-function","content":"dp[i][j] = max( dp[i][j] , dp[i-c0][j-c1]+1 ) Copy c0: the 0-count of current stringc1: the 1-count of current string "},{"title":"Iteration Direction","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#iteration-direction","content":"For each string (Loop 1) we are updating 2D dp matrix (Loop 2, Loop 3). For Loop2 and Loop3, We need to iteration from bottom-right to left-top because it should NOT re-use the result from current iteration. it will cause overcounting. "},{"title":"Solution","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#solution","content":"class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0 for _ in range(n+1)] for _ in range(m+1)] counts = [collections.Counter(s) for s in strs] counts = [(c['0'], c['1']) for c in counts] for c0,c1 in counts: # Loop 1 for i in range(m, c0-1, -1): # Loop 2 for j in range(n, c1-1, -1): # Loop 3 dp[i][j] = max(dp[i][j], dp[i-c0][j-c1]+1) return dp[m][n] Copy "},{"title":"Complexity","type":1,"pageTitle":"474. Ones and Zeroes","url":"algorithm/leetcode-474-ones-and-zeroes#complexity","content":"Time complexity : O(N*m*n)Space complexity : O(m*n) "},{"title":"698. Partition to K Equal Sum Subsets","type":0,"sectionRef":"#","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets","content":"","keywords":""},{"title":"Problem","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#problem","content":"Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4,3,2,3,5,2,1], k = 4 Output: true Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Copy Example 2: Input: nums = [1,2,3,4], k = 3 Output: false Copy "},{"title":"Solution 1 - Backtracking","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#solution-1---backtracking","content":"class Solution: def canPartitionKSubsets(self, nums: List[int], k: int) -> bool: allSum = sum(nums) if len(nums)<k or allSum %k !=0: return False nums.sort(reverse=True) # reverse for speed up parts = [allSum/k]*k def backtrack(parts, idx): if idx == len(nums): return sum(parts) == 0 for i in range(len(parts)): if parts[i]>= nums[idx]: parts[i] -= nums[idx] if backtrack(parts,idx+1): return True parts[i] += nums[idx] return backtrack(parts, 0) Copy "},{"title":"Solution 2 - Bit Mask","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#solution-2---bit-mask","content":"class Solution: def canPartitionKSubsets(self, nums: List[int], k: int) -> bool: if len(nums) < k or int(sum(nums)/k) != sum(nums)/k: return False N = len(nums) nums.sort(reverse=True) #[2]Sort the array in descending order, to improve run time. # print(\"nums\", nums) def dp(mask, cur, memo): # Top-down DP with memoization # print(\"cur\", cur) # print(\"mask in binary:\", format(mask, '0'+str(len(nums))+'b')) if mask == 0: return cur == 0 #[3] If mask == 0, all the elements have been used, and we need to see whether cur is equal to 0. elif cur == 0: return dp(mask, sum(nums)/k, memo) #[4] found an equal subset, but not some numbers haven't used. keep finding if (mask, cur) not in memo: res = False for bit in range(N): # 1 << bit: left shift, add bit num of 0 to the right of 1 # 1 << bit == pow(2, bit) if mask & (1 << bit): #[6] Check whether the number is unused. A set bit (1) means unused, 0 means used. if nums[bit] > cur: continue if dp(mask ^ (1 << bit), cur-nums[bit], memo): #[7] Use XOR to mark set bit as used (change from 1 to 0) res = True break memo[(mask, cur)] = res return memo[(mask, cur)] return dp(pow(2,N)-1, sum(nums)/k, dict()) #[8] Initialize mask as 11111...., N set bits. Copy "},{"title":"Explanation","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#explanation","content":"for sorted nums [1, 3 ,7, 10], bitmask 0000 means subset []bitmask 0110 means subset [3,7]bitmask 1111 means subset [1,3,7,10] start with mask 1111, means all unused 1 << bit == pow(2,bit) use AND gate (&) of mask and (1 << bit) to check if specific nums[bit] is unused. use XOR gate (^) of mask and (1 << bit) to mark nums[bit] as used. "},{"title":"Reference","type":1,"pageTitle":"698. Partition to K Equal Sum Subsets","url":"algorithm/leetcode-698-partition-to-k-equal-sum-subsets#reference","content":"https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/867956/Python3-Two-solutions-DP-with-Bit-mask(48ms)-DFS%2Bbacktracking-with-detailed-explanations "},{"title":"Index","type":0,"sectionRef":"#","url":"data-structure/index","content":"","keywords":""},{"title":"Links","type":1,"pageTitle":"Index","url":"data-structure/index#links","content":"Leetcode Learndata structures in practiceSecond Round: 初學者寫給初學者的演算法教學USFCA: Data Structure Visualizations "},{"title":"Skip List","type":0,"sectionRef":"#","url":"data-structure/skip-list","content":"","keywords":""},{"title":"What is Skip List?","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#what-is-skip-list","content":"A skip list is a probabilistic data structure.A skip list takes O(log(n)) time to add, erase and search, which is not possible in array or linked listA skip list is indexable to make random access take O(log n) time.A skip list has the same function and performance comparing with treap and red-black tree.That the skip list can be interpreted as a type of randomly balanced tree "},{"title":"Data Structure","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#data-structure","content":" a node: contains value valheight ha list of pointers node[] next from level 0 to level h.The next[i] representing the pointer of level i which points to the next node of same level i. listHeight: The height of a skip list is the height of its tallest node.MaxHeight: A constant that limit the height of skip list.sentinel: the dummy head node of list of every level. usually initialize with value of Number.MIN_SAFE_INTEGER, h of MaxHeight-1Every search starts from sentinel. probability p: If a node contains level from 0 to i, the probability that it has i+1 level. "},{"title":"Search","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#search","content":""},{"title":"The search path for the node containing 4.","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#the-search-path-for-the-node-containing-4","content":" The higher the level, the sparser the list.Search starts from high level to low level.Some nodes are skipped during search, resulting in the similarity to binary search. "},{"title":"Search Algorithm","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#search-algorithm","content":" // find the predecessor private Node findPred(int num) { Node cur = sentinel; for (int r = topLevel; r >= 0; r--) { while (cur.next[r] != null && cur.next[r].val < num) cur = cur.next[r]; stack[r] = cur; } return cur; } public boolean search(int target) { Node pred = findPred(target); return pred.next[0] != null && pred.next[0].val == target; } Copy "},{"title":"Add","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#add","content":""},{"title":"Adding an element to a skip list","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#adding-an-element-to-a-skip-list","content":"  private int pickHeight() { return Math.floor(Math.random() * MAX_HEIGHT); } public void add(int num) { Node pred = findPred(num); if (pred.next[0] != null && pred.next[0].val == num) { pred.next[0].count++; return; } Node newNode = new Node(num, pickHeight()); while (topLevel < newNode.h) stack[++topLevel] = sentinel; for (int i = 0; i <= newNode.h; i++) { //connect all prev and next nodes of level 0 - newNode.h newNode.next[i] = stack[i].next[i]; stack[i].next[i] = newNode; } } Copy "},{"title":"Random Access O(log(n))","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#random-access-ologn","content":" 1 10 o---> o---------------------------------------------------------> o Top level 1 3 2 5 o---> o---------------> o---------> o---------------------------> o Level 3 1 2 1 2 3 2 o---> o---------> o---> o---------> o---------------> o---------> o Level 2 1 1 1 1 1 1 1 1 1 1 1 o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o Bottom level Head 1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th NIL Node Node Node Node Node Node Node Node Node Node Copy we can store the length of list (bottom level)For example, to find 5th node, the path will be. Traverse from top level list, but moving to next node costs 10 more steps, which is too much.Therefore, drop one level to level 3 and move next to 4th node.drop one level to level 2.drop one level to bottom level.move next to 5th node. "},{"title":"Performance","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#performance","content":"A skip list of n nodes and probability p.Node number of level i is n * p^(i-1) first level: nsecond level: n * pthird level: n * p^2 average search length is the order of log(n) "},{"title":"Indexable skiplist","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#indexable-skiplist","content":""},{"title":"Balanced Tree v.s. Skip List","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#balanced-tree-vs-skip-list","content":"Concurrent programming when the tree is modified it often needs to re-balance, affecting large portions of the tree. Then it will require a mutex lock on many of the tree nodes.Inserting a node into a skip list is far more localized, only nodes directly linked to the affected node need to be locked. Skip List vs. Binary Search Tree "},{"title":"Application","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#application","content":""},{"title":"Skip list in Redis","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#skip-list-in-redis","content":"Redis 内部数据结构详解(6)——skiplist "},{"title":"Skip list in Lucene","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#skip-list-in-lucene","content":"How does lucene index documents?In a nutshell, Lucene builds an inverted index using Skip-Lists on disk, and then loads a mapping for the indexed terms into memory using a Finite State Transducer (FST). "},{"title":"Reference","type":1,"pageTitle":"Skip List","url":"data-structure/skip-list#reference","content":"Leetcode 1206. Design SkiplistOpen Data Structure 4 SkiplistsRedis 内部数据结构详解(6)——skiplist "},{"title":"Kustomization to Helm 3 Migration","type":0,"sectionRef":"#","url":"infra/kustomization-helm-migration","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#intro","content":"Currently we are using kustomize to manage Kubernetes resources. With a base YAML, there are different dimensions (e.g. environments, pools, clusters ) of variants we need to apply. The inheritence style of architecrue result in nested overlay folder structure like follow. This impairs readability. ├── deploy │ ├── hpa.yaml │ ├── deployment.yaml │ └── kustomization.yaml ├── overlay │ ├── env1 │ | ├── deploy │ | | ├── kustomization.yaml │ | | └── patch.yaml | | └── overlay │ | ├── pool1 | | | ├── deploy | | | └── overlay... │ | └── pool2 │ ├── env2 │ ├── env3 Copy Secondly, for template that only different in values like pool, for simplicity, we do NOT maintaining every pool overlay, instead using placeholders trick (e.g. __POOL__) and replace it after kustomize rendered. This makes the logic complex. "},{"title":"Migrate to Helm","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#migrate-to-helm","content":"After investigating Helm, another templating tool with different functionality and concept. The concept is more about composition compared to the inheritence style of kustomize. Helm and kustomize are not equivilant, Helm can do more than templating. Here I only use the templating funcions to replace kustomize. With Helm we could template with variables and assign variables in different values files. Therefore can \"flatten\" the overlay structure using values files. In short it is using values and template logic/functions to replace overlay logic. "},{"title":"Values","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#values","content":"Values is one of the built-in objects of Helm. It comes from: The values.yaml file in the chart The values.yaml file of a parent chart if this is a subchartDynamically passed arguments in CLI with --set (such as helm install --set foo=bar ./mychart) "},{"title":"Steps","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#steps","content":"Create Helm Charts with repect to each base YAML.Copy the base YAML into Chart templatesConvert kustomize overlays into Values and named template logics. value files naming convention value-${env}-${pool}-${cluster}, refering to original overlay logic but a flattened version.migrate env overlays into values-{env}.yamlmigrate pool overlays into values-{env}-{pool}.yaml Test the output, compare with existing ones. "},{"title":"Named Templates","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#named-templates","content":"Named TemplatesWhere does template {{ include \"some_template\" . }} come from ? template file _helpers.tpldefined in template files {{ define \"MY.NAME\" }} # body of template here {{ end }} Copy "},{"title":"Notes","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#notes","content":""},{"title":"1. Can we specify multiple values in Helm command?","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#1-can-we-specify-multiple-values-in-helm-command","content":"Yes, with helm template chartName -f my-first-value.yaml -f my-second-value.yaml... and the priority would from right to left. Helm will merge value files for us. Therefore we can minimize the duplication of values files "},{"title":"2. How to compare two YAML files ?","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#2-how-to-compare-two-yaml-files-","content":"During migration, we need to ensure the new method has exactly same output as original one. With 2 YAMLs with effectively same contents, fields or array could be different in order. There is no simple way to compare if two YAMLs are effectively same. Solution 1# Noted that YAML is a superset of JSON. So \"every JSON file is also a valid YAML file\". We could compare two YAMLs with 1) convert YAML to JSON 2) sort some specific keys 3) perform json diff Solution 2# dyff: A diff tool for YAML files, and sometimes JSON "},{"title":"3. Can we dynamically assign Values in Helm command?","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#3-can-we-dynamically-assign-values-in-helm-command","content":"Yes, referencehelm template --set foo=bar ./mychart "},{"title":"4. Can we do templating prefix-{{ .Values.foo }} in Value files?","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#4-can-we-do-templating-prefix--valuesfoo--in-value-files","content":"No, templating only works in template files (a.k.a templates folder inside Chart) "},{"title":"5. Use Values v.s. Template","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#5-use-values-vs-template","content":"Yaml files are key-value pairs. if different situation only differ in value, simply use Valuesif different situation also different in fields, we can if value is simple key-value pair (just like new HashMap<String, String>, or List<Map>), we could use golang template functions like range {{- range $key, $val := .Values.kvpairs }} {{ $key }}: {{ $val }} {{- end }} Copy if logic is more complex we could define Named Templates in _helpers.tpl and include it for certain condition. "},{"title":"6. Can Helm escape {{ and }}","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#6-can-helm-escape--and-","content":"Yes, in template. ref: Can Helm support to ignore {{expr}} which is just for configuration but not render? "},{"title":"7. Can we use some template outside current Chart ?","type":1,"pageTitle":"Kustomization to Helm 3 Migration","url":"infra/kustomization-helm-migration#7-can-we-use-some-template-outside-current-chart-","content":"Yes, see Library Charts "},{"title":"Concurrency vs. Parallelism v.s. Coroutine","type":0,"sectionRef":"#","url":"programming/concurrent-vs-parallelism","content":"","keywords":""},{"title":"Intro: The Free Lunch Is Over","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#intro-the-free-lunch-is-over","content":"The major processor manufacturers and architectures, from Intel and AMD to Sparc and PowerPC, have run out of room with most of their traditional approaches to boosting CPU performance. Instead of driving clock speeds and straight-line instruction throughput ever higher, they are instead turning en masse to hyperthreading and multicore architectures. more: The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software  "},{"title":"Multi Threading","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#multi-threading","content":"CPU will manage/scheduling its own threads.Multi-threading is the prerequisite of multi-processing  "},{"title":"Benefits of Multi Threading","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#benefits-of-multi-threading","content":"Responsiveness# Multi-threading in an interactive application may allow a program to continue running even if a part (thread) of it is blocked or is performing a lengthy operation, thereby increasing responsiveness to the user. Resource Sharing# (Compared to)Processes may share resources only through techniques such as Message Passing and Shared Memory.However, threads share the memory and the resources of the process to which they belong by default. Economy# Allocating memory and resources for process creation is a costly job in terms of time and space.Threads share memory with the process it belongs, it is more economical to create and context switch threads. Scalability# If there is only one thread then it is not possible to divide the processes into smaller tasks for parallelism.Single threaded process can run only on one processor regardless of how many processors are available.  "},{"title":"Concurrency & Parallelism","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#concurrency--parallelism","content":"Concurrency is composition of independently executing things (typically, functions). We often use the word process to refer to such running thing, and we don't mean unix process, but rather a process in the abstract, general sense. Parallelism is simultaneous execution of multiple things. Those things might or might not be related to each other. Concurrency is about dealing with a lot of things at once. Parallelism is about doing a lot of things at once.The ideas are, obviously, related, but one is inherently associated with structure, the other is associated with execution. Concurrency is structuring things in a way that might allow parallelism to actually execute them simultaneously. But parallelism is not the goal of concurrency. The goal of concurrency is good structure. "},{"title":"1. Concurrency (Multi threading)","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#1-concurrency-multi-threading","content":" An application is making progress on more than one task at a time inside the application, resulting in a multi-threaded processIn contrast to: Sequential ExecutionWhen executing multi-threaded process on a processor, the processor can switch execution resources between threads, resulting in concurrent execution.When talking about concurrency we talk about something happen on a singe processor. Applications# goroutine in golang.JavaScript has a concurrency model based on an event loop.Promise in Javascript is asynchronous programming but not Concurrency. "},{"title":"2. Parallel Execution","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#2-parallel-execution","content":" A multi-threaded process executed in a shared-memory multi-CPU environment. threads are distributed among multiple CPUs at the same time. threads on different CPUs are executed in parallel. Parallel Execution is not equal to parallelism. "},{"title":"3. Parallel Concurrent Execution","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#3-parallel-concurrent-execution","content":" Simply the 1. Concurrency (Multi threading) + 2. Parallel Execution both happens. threads executed on a CPU are executed concurrently threads executed on different CPUs are executed in parallel. "},{"title":"4. Parallelism (Multi Processing)","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#4-parallelism-multi-processing","content":" When executing multi-processing program on multiple processors, tasks are split int sub-tasks and process by multiple threads.Resource are isolated among processors.Each process can have many threads running in its own memory space. Scenarios# multi-core processorsgraphics processing unit (GPU)field-programmable gate arrays (FPGAs)distributed computer clusters  "},{"title":"Coroutine v.s. Thread","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#coroutine-vs-thread","content":" Threads are scheduled by CPU. Coroutines are scheduled by User. Threads are typically preemptively scheduled. Coroutines are cooperatively scheduled. programs using threads must be careful about locking. programs using coroutines can often avoid locking entirely.  "},{"title":"Goroutine in Golang","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#goroutine-in-golang","content":" In short, Goroutine is something between thread and coroutine "},{"title":"Why Why goroutines instead of threads?","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#why-why-goroutines-instead-of-threads","content":"Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently executing functions—coroutines—onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won't be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: they have little overhead beyond the memory for the stack, which is just a few kilobytes. "},{"title":"Goroutine v.s. coroutine","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#goroutine-vs-coroutine","content":"goroutines imply parallelism; coroutines works on single thread.goroutines communicate via channels; coroutines communicate via yield and resume operationsgoroutines has controls of max thread number via $GOMAXPROCS set by user. "},{"title":"Reference","type":1,"pageTitle":"Concurrency vs. Parallelism v.s. Coroutine","url":"programming/concurrent-vs-parallelism#reference","content":"Summary of Concurrency Is Not Parallellism, a talk by Rob Pike並行程式設計: 概念Concurrency vs. ParallelismGolang FAQ: goroutines進程 (Process)、線程 (Thread)、協程 (Coroutine) 的概念講解Preemptive vs Non-Preemptive Scheduling: Key DifferencesGo Language Patterns: Coroutines當一個 goroutine 創建新的 goroutine 時，scheduler 會選誰優先執行？ "},{"title":"Clean Code - Object Oriented Design","type":0,"sectionRef":"#","url":"programming/clean-code-note","content":"","keywords":""},{"title":"前言","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#前言","content":"公司新訓讀 Clean Code 紀錄。 "},{"title":"Inheritance 繼承","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#inheritance-繼承","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義","content":"繼承可以基於某個父類別對物件的定義加以擴充，而制訂出一個新的子類別定義。 子類別可以繼承父類別原來的某些定義子類別可以增加原來的父類別所沒有的定義子類別可以重新定義父類別中的某些特性 "},{"title":"優點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#優點","content":"子類可以輕鬆的擁有父類的方法來方便地實現對父類的擴展。 "},{"title":"缺點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#缺點","content":"父子之間的耦合度高，如果修改父類則子類也需要作出相應的修改，或是為了不同種子類而增加系統複雜度。 "},{"title":"使用繼承的時機:","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#使用繼承的時機","content":"Polymorphism兩者關係是 X 是 A 的一種，並且 X 是延伸 A 而不需要去修改 A 的情況，此情況以外的建議用 Composition。  "},{"title":"Composition 複合","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#composition-複合","content":"在我們對現實中的某些事物抽象成 Class 時，可能會形成很複雜的 Class，為了更簡潔的進行開發，我們經常把其中相對比較獨立的部分拿出來定義成一個個簡單的 Class，由這些簡單的 Class 再組成我們想要的類。Composition 最簡單的做法就是設計 Class 的時候把要組合的對象加入到自己之中作為自己的 local variable，也就是 has 的概念。 這樣的結果就是被加入的 Class 和目前的 Class 是一個低耦合狀態，不需要因為修改一個 Class 而連帶修改其他的 Class。 "},{"title":"優點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#優點-1","content":"開發的時候夠有彈性。 "},{"title":"缺點","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#缺點-1","content":"容易產生過多的 Object。 "},{"title":"使用時機","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#使用時機","content":"當我們覺得當 A 有 X 能力的時候，像是鳥可以飛，就可以把 fly 當作變數加入鳥的 Class 裡。  "},{"title":"Law of Demeter","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#law-of-demeter","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義-1","content":"又稱作“最少知識法則”或“don’t talk to strangers”。如果一個 Object 知道了太多不屬於他本身的內容，則代表他和其他 Object 之間的耦合程度越高，在面對需要變更的時候難以修改。目的是要降低物件之間的依賴關係。 a method f of a class C should only call the methods of these: CAn object held in an instance variable of C.An object created by fAn object passed as an argument to fglobal variables 要先區分 Object 和 Data Structure，Object 這種以 Method 為核心的，才適用 Law of Demeter，Data structure 是以資料為核心，存取資料並不涉及行為，不違反 Law of Demeter。 "},{"title":"如何不違反","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#如何不違反","content":"Example 1 - 避免 method chainning# public boolean isValidEmployee(Employee employee) { String primaryEmailAddress = employee.getEmail().getPrimaryEmailAddress(); long mobile = employee.getContactNumber().getMobile(); if (primaryEmailAddress != null && mobile != 0) {return true;} return false; } Copy public boolean isValidEmployee(Employee employee) { //把檢查的責任歸屬放在employee內部 boolean isValidPrimaryEmailAddress = employee.isValidPrimaryEmailAddress(); boolean isValidMobile = employee.isValidMobile(); if (isValidPrimaryEmailAddress && isValidMobile) {return true;} return false; } Copy Example 2 - 只傳入函式需要知道的資訊。# public class Game { public Board board { get; private set; } public Game() { board = new Board(); } public void MarkBoard(int space, string marker) { board.spaces[space] = marker; //有問題 } } public class Board { public string[] spaces {get; private set;} public Board() { spaces = new string[] {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; } } Copy public class Game { public Board board { get; private set; } public Game() { board = new Board(); } public MarkBoard(int space, string marker) { board.Mark(space, marker) //呼叫board內的Mark實作。 } } public class Board { public string[] spaces {get; private set;} public Mark(int space, string marker) { spaces[space] = marker } public Board() { spaces = new string[] {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; } } Copy  "},{"title":"Inversion of Control (IoC)","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#inversion-of-control-ioc","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義-2","content":"Program 應該要依賴於抽象化介面，而不是實作細節，介面的功能應該以 Client 端的觀點定義。 "},{"title":"概念舉例","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#概念舉例","content":"今天有電腦(高層次)和記憶體(低層次)，還沒有實行 IoC 之前，電腦規格會依賴記憶體，如果更改記憶品牌則會導致問題，因為記憶體的細節規格不同。 IoC 的概念就是，應該要有 Interface 來把控制權轉換到Interface上，也就是名稱中 Inversion 的意思，電腦和 Interface 通常是 bundle 在一起的，實行後情況變成是，電腦依賴 Interface，記憶體也依賴 Interface ，也就是控制反轉了。  "},{"title":"Dependency Injection(DI)","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#dependency-injectiondi","content":""},{"title":"定義","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#定義-3","content":"傳統產生物件時，物件會自己產生自己需要的 dependency。 而 DI 則是產生物件時，此物件需要的 dependency 需由 Client 端提供，像是注入一樣。 "},{"title":"相關原則","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#相關原則","content":"衍生自相關原則： S.O.L.I.D. Principle 中的 Dependency Inversion principleInversion of Control（IoC) "},{"title":"概念","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#概念","content":"Object CompositionObject Lifetime ManagementObject Interception(Cross-Cutting-Concern) "},{"title":"Dependency Injection vs Composition","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#dependency-injection-vs-composition","content":"兩種都是把別的 Object 加入自己的 local variable 中，差異在哪？ //Dependency Injection class Employee { private Address address; public Employee( Address newAddress //注入 ) { this.address = newAddress; // 差異點 } public Address getAddress() { return this.address; } public void setAddress( Address newAddress //注入 ) { this.address = newAddress; } } Copy //Composition final class Car { private final Engine engine; Car(EngineSpecs specs) { engine = new Engine(specs); } void move() { engine.work(); } } Copy Dependency Injection: Address 和 Employee 彼此獨立存在，相互依賴。 Composition: The Engine 存在 Car 當中。 "},{"title":"Dependency Injection v.s. Functional Programming","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#dependency-injection-vs-functional-programming","content":"參考: Dependency rejection by Mark Seemann DI 跟 FP 的差異點在哪裡？# OO 跟 FP 的概念其實是根本上不同，FP 希望 function 是 pure 的，但 Dependecy 在 FP 的角度基本上是 impure，所以 Pure function 不能呼叫 impure function。但是 impure function 可以呼叫 pure function  "},{"title":"實行 Inversion of Control 的實際步驟","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#實行-inversion-of-control-的實際步驟","content":" Tightly coupled classesImplement IoC using factory patternImplement DIP by creating abstractionImplement Dependency InjectionDI containerLoosely coupled classes "},{"title":"Example","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#example","content":"Tightly coupled classes class Computer { // 依賴於低階模組：『具體』的英雄聯盟，而非 『抽象』的遊戲 private LOL lol; public Computer() { lol = new LOL(); } public Computer(LOL lol) { this.lol = lol; } public void playGame() { if (lol != null) lol.play(); } } class LOL { public void play() { System.out.print(\"LOL\"); } } Copy Implement IoC using factory pattern class Computer { public void playLOL() { LOL lol = new LOL(); lol.play(); } public void playWarcraft() { Warcraft warcraft = new Warcraft(); lol.play(); } } class LOL { public void play() { System.out.print(\"LOL\"); } } class Warcraft { public void play() { System.out.print(\"Warcraft\"); } } Copy Implement Dependency Injection public class Main { public static void main(String[] args) { GameFactory factory = new ImplGameFactory(); Game game = factory.createGame(); Computer computer = new Computer(game); } } class Computer { private Game game; // Constructor Injection public Computer(Game game) { this.game = game; } ... } Copy  "},{"title":"Reference","type":1,"pageTitle":"Clean Code - Object Oriented Design","url":"programming/clean-code-note#reference","content":"Clean CodeThe Law of DemeterDependency Injection 是什麼？Difference between dependency and composition?Dependency rejection by Mark Seemann控制反轉 (IoC) 與 依賴注入 (DI) "},{"title":"Closure","type":0,"sectionRef":"#","url":"programming/js-closure","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Closure","url":"programming/js-closure#intro","content":"網路上許多閉包的教學都沒有直接明確的定義，只知道 use case 和長什麼樣子。直到看到這篇[教學] JavaScript Closure (閉包)、函式與語彙環境，搭配You-Dont-Know-JS一起讀才豁然開朗。 "},{"title":"Definition","type":1,"pageTitle":"Closure","url":"programming/js-closure#definition","content":"MDN/Closures的定義 A closure is the combination of a function and the Lexical Environment within which that function was declared. JavaScript 中的 Closure 是函式以及其語彙環境 (Lexical Environment) 的組合。Closure 是一個函式能夠存取自己被宣告時的環境中的變數。如果不處理函數，則 Closure 不適用。一個 Object 不能有 Closure ，一個 Clas 也不能有閉包。 Lexical Environment 詞法作用域是一套關於引擎如何尋找變量以及會在何處找到變量的規則。詞法作用域最重要的特徵是它的定義過程發生在代碼的書寫階段。 "},{"title":"Example","type":1,"pageTitle":"Closure","url":"programming/js-closure#example","content":"function makeFunc() { // 1 let name = \"John\"; // 2 function displayName() { // 3 console.log(name); } return displayName; // 4 } let func1 = makeFunc(); // 5 func1(); Copy "},{"title":"特性","type":1,"pageTitle":"Closure","url":"programming/js-closure#特性","content":""},{"title":"閉包 + 函式可被回傳","type":1,"pageTitle":"Closure","url":"programming/js-closure#閉包--函式可被回傳","content":"結果: 函式可以在作用域以外之處執行 "},{"title":"閉包 + 函式可被回傳 + Lexical Environment","type":1,"pageTitle":"Closure","url":"programming/js-closure#閉包--函式可被回傳--lexical-environment","content":"原因: 在 JavaScript 中，即使在外層區塊(makeFunc)已經回傳的狀況下，由於內部作用域(displayName)依然存在，只要內層區塊還保留著一份參考，那麽外層區塊的環境不會隨著回傳而被垃圾回收機制回收，我們依然可以存取外層環境中的變數(//5)。結果: 閉包 (closure) 可以「保留」函數宣告的環境。 "},{"title":"一定要return?","type":1,"pageTitle":"Closure","url":"programming/js-closure#一定要return","content":"即使 displayName 只有被執行沒有 return，也可以稱作閉包。但如果不 return，就無法使用這個閉包。return 目的只是要讓作用域外別的函式可以訪問到這個 displayName 函式，因此 return 與否，與是否是閉包無關。 "},{"title":"Reference","type":1,"pageTitle":"Closure","url":"programming/js-closure#reference","content":"You-Dont-Know-JSMDN/Closures[教學] JavaScript Closure (閉包)、函式與語彙環境所有的函式都是閉包：談 JS 中的作用域與 ClosureDay6 [JavaScript 基礎] 垃圾回收機制 "},{"title":"Functional Programming","type":0,"sectionRef":"#","url":"programming/js-fp","content":"","keywords":""},{"title":"Concepts","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#concepts","content":""},{"title":"Side Effect","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#side-effect","content":"函數影響或修改到其他作用域的值，稱作 Side Effectpure function 沒有 Side Effect "},{"title":"Referential transparency","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#referential-transparency","content":"pure function 的必要條件，也就是所有pure function必須是 referentially transparent 的。給定一個 function 和一個 input 值，始終會收到相同的 out。 也就是說函數中沒有使用外部狀態。 "},{"title":"Immutability","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#immutability","content":"在 Javascript 中，objct 是通過 pass by reference 的，因此我們可以直接修改(mutate) Object。在 Functional Programming 中每當我們處理一個 Obect 時，我們都會回傳 new Object 而不是修改/污染原 Object，即 Immutability。 "},{"title":"Declarative 宣告式 vs. Imperative 命令式","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#declarative-宣告式-vs-imperative-命令式","content":"Imperative# 通常用在 OOP著重在 HOW，具體表達程式碼該做什麼才能達到目標，程式一步一步按著順序照著你給他指示執行。比較常運用 Statement ，也就是 if , while , for , switch 等。 Declarative# 通常用在 FP著重在該做什麼 WHAT ，並採取抽象化流程。比較常運用表達式 expression，表達式特色是單純運算並一定會有返回值。 "},{"title":"Point free function","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#point-free-function","content":"通過刪除不必要的參數 mapping 來提供整潔性。 "},{"title":"Compose v.s. Pipe","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#compose-vs-pipe","content":"compose(fn2, fn1) = fn2( fn1() ): 從右到左pipe(fn2, fn1) equals to fn1( fn2() ): 從左到右 const pipe = reverseArgs(compose); Copy  "},{"title":"Functional Programming 的基本技巧","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#functional-programming-的基本技巧","content":""},{"title":"Closure","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#closure","content":"JavaScript 中的 Closure 是函式以及其語彙環境 (Lexical Environment) 的組合。Closure 是一個函式能夠存取自己被宣告時的環境中的變數。如果不處理函數，則 Closure 不適用。一個 Object 不能有 Closure ，一個 Class 也不能有閉包。Closures 在 runtime 時 function 建立後才誕生。 "},{"title":"Curry","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#curry","content":"Curry/Currying 是一種將帶有多個參數的 function 轉換為一系列一元函數的技術，每個一元函數都只有一個參數。Currying 和 partial application相關但不相同。 Example: Hard Coded Currying# const add3Args = (a, b, c) => a + b + c; const addCurried = (a) => (b) => (c) => a + b + c; add(2, 3, 6); //11 addCurried(2)(3)(6); //11 Copy "},{"title":"Composition","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#composition","content":"Curried function 非常適合 function 組合。 function 的組合：每個 function 都接收上一個 function 的返回值。 // in algrebra f . g . h = f(g(h(x))) Copy //in Javascript const compose = (...fns) => (x) => fns.reduceRight((y, f) => f(y), x); Copy  "},{"title":"Interview Problem: Implement Currying","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#interview-problem-implement-currying","content":"const add3Args = (a, b, c) => a + b + c; // args長度固定 const add = (...args) => args.reduce((result, arg) => result + arg); // args 長度不固定 const curry = (fn, arity = fn.length) => (function nextCurried(prevArgs) { return (nextArg) => { const args = [...prevArgs, nextArg]; if (args.length >= arity) { return fn(...args); } else { return nextCurried(args); } }; })([]); curry(add3Args)(1)(3)(7); // 11 curry(add, 3)(1)(3)(7); // 11 Copy arity: 預計傳入參數數量，如果長度不固定需要 specify。 初始 [] 做為 prevArgs，收集已傳入的參數。 接每一次傳入的實際參數 nextArg 與 prevArgs 合併成 args。 當 args 長度小於 arity 時，return nextCurried(prevArgs)，prevArgs 也就是下一輪的 prevArgs。 當 args 長度大於 arity 時，代表已收集到足夠的 args，就利用這些 args，呼叫原函數 fn。 reference: 第 15 题：实现 add(1)(2)(3) #21  "},{"title":"Interview Problem: Sum of Arguments","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#interview-problem-sum-of-arguments","content":""},{"title":"Problem","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#problem","content":"Create a sum function that will calculate the sum of arguments. if there aren’t any arguments, return the result, if there are any arguments, return a function that can be used for the next calculation. Example sum() // return 0; sum(1)() // return 1; sum(1, 1, 1)() // return 3; sum(1)(1)(1)() // return 3; sum(1)(1, 1, 1, 1)(1)() // return 6 sum(1) // return a function sum(1)…….(1, 1, 1,…1) // return a function Copy "},{"title":"Solution","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#solution","content":"function sum(...args) { let sum = 0; sum += args.reduce((res, el) => res + el, 0); function f(...fArgs) { if (fArgs.length === 0) return sum; sum += fArgs.reduce((res, el) => res + el, 0); return (...newArgs) => f(...newArgs); } return (...newArgs) => f(...newArgs); } Copy  "},{"title":"Javascript Functional Libraries","type":1,"pageTitle":"Functional Programming","url":"programming/js-fp#javascript-functional-libraries","content":"LodashUnderscore.jslazyJSRamda "},{"title":"Javascript Dev Notes","type":0,"sectionRef":"#","url":"programming/js-dev-note","content":"","keywords":""},{"title":"1. Trace Call Stack","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#1-trace-call-stack","content":"this is useful especially in developing / debugging multi-repo console.log((new Error()).stack.split(\"\\n\"))arguments.callee.caller.toString() (not work in strict mode) "},{"title":"2. console.log an Object is pass by reference","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#2-consolelog-an-object-is-pass-by-reference","content":"object is pass by referenceobject may have changed when log shows Don't use console.log(obj), use console.log(JSON.parse(JSON.stringify(obj))). This way you are sure you are seeing the value of obj at the moment you log it. Otherwise, many browsers provide a live view that constantly updates as values change. This may not be what you want. reference: Logging objects  "},{"title":"3. Initializing 2D array with Array.fill","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#3-initializing-2d-array-with-arrayfill","content":"if filled value is Object, Array or function, e.g. pass by reference, they will reference to the same object. const list = new Array(3).fill(new Array(4).fill(1)); const list2 = new Array(3).fill(null).map(() => new Array(4).fill(1)); list[1][2] = 2; list2[1][2] = 2; console.log(list); // false //[ // [ 1, 1, 2, 1 ], // [ 1, 1, 2, 1 ], // [ 1, 1, 2, 1 ] //] console.log(list2); // correct //[ // [ 1, 1, 1, 1 ], // [ 1, 1, 2, 1 ], // [ 1, 1, 1, 1 ] //] Copy list1 filled each row with same reference of new Array(4).fill(1). if modified list[1][2], every row of index 2 will also be modified.list two is creating 2D array of each different row.  "},{"title":"4. Deep Copy v.s. Shallow Copy","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#4-deep-copy-vs-shallow-copy","content":"Shallow Copy# Array.prototype.slice()Object.assign({}, obj);Spread Syntax: A2 = {...A1} Deep Copy# JSON.parse(JSON.stringify(object)) If you do not use circular reference, Dates, functions, undefined, Infinity, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, it is a very simple one liner to deep clone an object. with library: lodash - cloneDeep  "},{"title":"5. Manipulating with floating-point number","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#5-manipulating-with-floating-point-number","content":"JavaScript has a single and unpredictable number type, 64-bit floating point. 0.1 + 0.2 === 0.3; // false function numbersCloseEnoughToEqual(n1, n2) { return Math.abs(n1 - n2) < Number.EPSILON; } numbersCloseEnoughToEqual(0.1 + 0.2, 0.3); Copy  "},{"title":"6. Function arguments are pass-by-reference","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#6-function-arguments-are-pass-by-reference","content":"function foo(x) { x.push(4); x; // [1,2,3,4] x = [4, 5, 6]; //re-assign, reference changed x.push(7); x; // [4,5,6,7] } var a = [1, 2, 3]; foo(a); a; // [1,2,3,4] Copy  "},{"title":"7. Key order of Object.keys(obj)?","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#7-key-order-of-objectkeysobj","content":"ES5# depend on browserref: ECMA 5.0 Object.keys (O) For each own enumerable property of O whose name String is P Call the [[DefineOwnProperty]] internal method of array with arguments ToString(index), the PropertyDescriptor {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. Increment index by 1. If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration order must be used in step 5 of this algorithm. ES6:# depend on OwnPropertyKeys methodReflect.ownKeys also depend on OwnPropertyKeysOrder integers: in numeric orderstrings: in chronological orderSymbols: in chronological order ref: ECMA 6.0 Object.keys ( O ) const obj = { 2: \"integer: 2\", foo: \"string: foo\", \"01\": \"string: 01\", 1: \"integer: 1\", [Symbol(\"first\")]: \"symbol: first\", }; obj[\"0\"] = \"integer: 0\"; obj[Symbol(\"last\")] = \"symbol: last\"; obj[\"veryLast\"] = \"string: very last\"; console.log(Reflect.ownKeys(obj)); // [ \"0\", \"1\", \"2\", \"foo\", \"01\", \"veryLast\", Symbol(first), Symbol(last) ] Copy  "},{"title":"8. Remove Duplicate Element in Array","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#8-remove-duplicate-element-in-array","content":"const chars = [\"A\", \"B\", \"A\", \"C\", \"B\"]; const uniqueChars = chars.filter((c, index) => chars.indexOf(c) === index); //[ 'A', 'B', 'C' ] Copy "},{"title":"9.DOM Element","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#9dom-element","content":""},{"title":"DOM Element is a special object","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#dom-element-is-a-special-object","content":"var a = document.createElement(\"div\"); typeof a; // \"object\" Object.prototype.toString.call(a); // \"[object HTMLDivElement]\" a.tagName; // \"DIV\" Copy Cannot call some built-in methods such as toString()Cannot be overwritten / override some properties such as this "},{"title":"DOM Element will produce global variable","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#dom-element-will-produce-global-variable","content":"be careful for duplicate naming. <div id=\"foo\"></div> Copy console.log(foo); // HTML Element Copy "},{"title":"10. using await inside setInterval is pointless","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#10-using-await-inside-setinterval-is-pointless","content":"since interval won't wait for await async function getData (){ return fetch(\"url...\") } const timer = setInterval( await getData(); ,1000) Copy can change into async function getData() { return fetch(\"https://google.com\"); } async function sleep(ms) { return await new Promise((resolve) => setTimeout(resolve, ms)); } function periodicGetData() { return new Promise(async (resolve, reject) => { if (some_condition) { resolve(); } const res = await getData(); if (res instanceof Error) { reject(res); } console.log(\"res\", res); await sleep(1000); return periodicGetData(); }); } periodicGetData(); Copy  "},{"title":"Reference","type":1,"pageTitle":"Javascript Dev Notes","url":"programming/js-dev-note#reference","content":"You Don't Know JSProperty order is predictable in JavaScript objects since ES2015 "},{"title":"Understanding Memory Allocations in Go","type":0,"sectionRef":"#","url":"programming/memory-allocations-golang","content":"","keywords":""},{"title":"Links","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#links","content":"Understanding Allocations in GoStack vs Heap: Know the DifferenceAn overview of memory management in GoGolang Tutorial 3 - Golang pointers explained, once and for all "},{"title":"Stack v.s. Heap","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#stack-vs-heap","content":"Parameter\tStack\tHeapType of data structures\tA stack is a linear data structure.\tHeap is a hierarchical data structure. Access speed\tHigh-speed access\tSlower compared to stack Space management\tSpace managed efficiently by OS so memory will never become fragmented.\tHeap Space not used as efficiently. Memory can become fragmented as blocks of memory first allocated and then freed. Access\tLocal variables only\tIt allows you to access variables globally. Limit of space size\tLimit on stack size dependent on OS.\tDoes not have a specific limit on memory size. Resize\tVariables cannot be resized\tVariables can be resized. Memory Allocation\tMemory is allocated in a contiguous block.\tMemory is allocated in any random order. Allocation and Deallocation\tAutomatically done by compiler instructions.\tIt is manually done by the programmer. Deallocation\tDoes not require to de-allocate variables.\tExplicit de-allocation is needed. Cost\tLess\tMore Implementation\tA stack can be implemented in 3 ways simple array based, using dynamic memory, and Linked list based.\tHeap can be implemented using array and trees. Main Issue\tShortage of memory\tMemory fragmentation Locality of reference\tAutomatic compile time instructions.\tAdequate Flexibility\tFixed size\tResizing is possible Access time\tFaster\tSlower "},{"title":"Stack","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#stack","content":"We don’t need to garbage collection on stack "},{"title":"Stack Frame","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#stack-frame","content":"A call stack is composed of 1 or many several stack frames. Each stack frame corresponds to a call to a function or procedure which has not yet terminated with a return.Function arguments, local variables and return address are stored in stack frame "},{"title":"Function and Stack","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#function-and-stack","content":"Each function call pushes a new frame to the stackEach returning function pops from the stack. "},{"title":"Heap","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#heap","content":"the heap contains values that are referenced outside of a function.When the programmer defines an object that gets placed on the heap, the needed amount of memory is allocated and a pointer to it is returned.As a program runs, the heap will continue to grow as objects are added unless the heap is cleaned up. "},{"title":"Process Memory Layout in Golang","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#process-memory-layout-in-golang","content":" "},{"title":"How do we know when a variable is allocated to the heap?","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#how-do-we-know-when-a-variable-is-allocated-to-the-heap","content":"When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame.However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. "},{"title":"Garbage collection (GC)","type":1,"pageTitle":"Understanding Memory Allocations in Go","url":"programming/memory-allocations-golang#garbage-collection-gc","content":""},{"title":"Immutability","type":0,"sectionRef":"#","url":"programming/js-immutability","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#introduction","content":"Javascript reference data type Object has mutable characteristics. The benefit of mutability is memory-saving. However in frontend scenario, the disadvantage of side effect often outweigh the advantage.Without immutability, you might have to pass an object around between different scopes, and you do not know beforehand if and when the object will be changed. The code becomes unpredictable and is difficult to debug.Immutability in Javascript means we cannot update variable by reference. Whenever we want to update a variable, we create a new reference.  "},{"title":"Benefits of Immutability","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#benefits-of-immutability","content":"PredictabilityMutation hides change, which create (unexpected) side effects, which can cause nasty bugs. When you enforce immutability you can keep your application architecture and mental model simple. Mutation TrackingImmutability allows you to optimize your application by making use of reference and value equality. This makes it really easy to see if anything has changed. Boost performance (indirectly)When facing mutable data structure, we want to know if object change by iterating through all properties. In contrast, facing immutable data structure, we only have to check equality of reference. Reduce the need of lock when concurrent programming (not completely) The core problem of multi thread programming is race condition. We need to ensure atomic characteristic inside critical operation by some methods such as lock. "},{"title":"How immutability boosts React performance","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#how-immutability-boosts-react-performance","content":""},{"title":"Background","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#background","content":"React maintains an internal representation of the UI, the so-called virtual DOM.When a property or the state of a component changes, this virtual DOM is updated to reflect those changes. Manipulating the virtual DOM is easier and faster because nothing is changed in the UI.Then, React compares the virtual DOM with a version before the update in order to know what changed. This is the reconciliation process. "},{"title":"When we want to avoid unnecessary re-render","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#when-we-want-to-avoid-unnecessary-re-render","content":"React in default re-render components whenever state or props change.Sometimes knowing what changes could be very difficult when props is deep nested object.If the props are guaranteed the immutability characteristic, we can simply know wether the props change by performing simple equality check without dive into nested object and compare values respectively. class MyComponent extends Component { // ... shouldComponentUpdate(nextProps, nextState) { if (this.props !== nextProps) { return true; } return false; } // ... } Copy  "},{"title":"How to implement immutability?","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#how-to-implement-immutability","content":"To clarify before we start, when talking about create a new reference when updating a variable, we do not refer to performs deep copy operation JSON.parse(JSON.stringify(obj)) because it simply recreate all properties even of those not changed. This actually hurt performance. "},{"title":"Persistent data structures","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#persistent-data-structures","content":"Persistent data structures enforces a constraint that all operations will return a newer version of that data structure and keep the original structure intact,e.g. reusing existing nodes as much as possible. "},{"title":"Spread Operator (ES6) (without Library)","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#spread-operator-es6-without-library","content":"When perform state update in React, we often need to do operations such as modify a properties in Object, append element to array, andinsert array. Thanks to Spread Operator in Javascript ES6, we can only update the specific property and keep other references intact. Rect officially recommend this way to do state update, The Power Of Not Mutating Data. modify a properties in Object const [myData, setMyData] = useState({ myName: \"Howard\", myPhoneNum: \"0912345678\" }); setMyData((prevState) => { return { ...prevState, myName: \"Cool Howard\" }; }); // { myName: \"Cool Howard\", myPhoneNum: \"0912345678\" } Copy append element to array const [sentence, setSentence] = useState([\"You\", \"are\", \"an\", \"awesome\"]); setSentence((prevState) => [...prevState, \"programmer\"]); // [\"You\", \"are\", \"an\",\"awesome\", \"programmer\"] Copy insert array const [sentence, setSentence] = useState([\"You\", \"are\", \"awesome\", \"programmer\"]); setSentence((prevState) => [...prevState.slice(0, 2), \"an\", ...prevState.slice(2)]); // [\"You\", \"are\", \"an\",\"awesome\", \"programmer\"] Copy  "},{"title":"Immutable.js library","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#immutablejs-library","content":"Nowadays, Immutable.js is the most famous library. It implements fully persistent data structures including: List, Stack, Map, OrderedMap, Set, OrderedSet and Record.It provides mutative API to update data in an efficient and immutable way. "},{"title":"Behind the scene","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#behind-the-scene","content":"How Immutable Data Structures (E.g. Immutable.js) are OptimizedImmutable.js, persistent data structures and structural sharing These articles illustrated how to implement object into immutable as well as persistent data structure using Trie "},{"title":"When to use immutable library?","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#when-to-use-immutable-library","content":"Please don’t take this article to mean “you should always use Immutable.js.” No, I’m just trying to highlight its benefits in this article and explain why it’s recommended a lot. There are still drawbacks using immutable library: We will couple the most basic data structure with a library.The size of package increase.When frequently communicating with server, we will have to convert the data structure between library and native Javascript.  "},{"title":"Reference","type":1,"pageTitle":"Immutability","url":"programming/js-immutability#reference","content":"Immutable Data Structures and JavaScriptImmutability in React: There’s nothing wrong with mutating objectsImmutable.jsImmutable 详解及 React 中实践 #3Immutable.js, persistent data structures and structural sharingPersistent Data Structure "},{"title":"React Dev Notes","type":0,"sectionRef":"#","url":"react/react-dev-detail","content":"","keywords":""},{"title":"1. reducer of useReducer and updater function of setState will be called twice in strict mode.","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#1-reducer-of-usereducer-and-updater-function-of-setstate-will-be-called-twice-in-strict-mode","content":"reference: React.StrictMode causes setState to fire twice #12856should not perform side effect inside updater function "},{"title":"2. previous state of useReducer reducer and updater function of setState IS PASS BY REFERENCE.","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#2-previous-state-of-usereducer-reducer-and-updater-function-of-setstate-is-pass-by-reference","content":"Don't directly modify previous stateDeep copy previous state if you want to yous. "},{"title":"3. reducer should remain constant reference","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#3-reducer-should-remain-constant-reference","content":"Not working example const reducer = (state,action)=>{...} const getReducer = (someProps) => reducer; const [state, dispatch] = (getReducer(props), initialState); Copy props should by pass into reducer with action "},{"title":"4. return a function in useCallback","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#4-return-a-function-in-usecallback","content":"Purpose: Try to memoize the callback function getOnClick for Child.Assume We need information of index to get the real onClick callback. Not working example# only (idx)=>{...} is memoized, but not (e)=>{...} .Child is still getting newly created (e)=>{...} on every render. const getOnClick = useCallback((idx)=>(e)=>{...},[...]); const List = list.map((el,idx)=><Child onClick={getOnClick(idx)}/>); Copy Working example:# we can generate pass idx to Child, than (e)=>{...} is actually generated inside Child.getOnClick of Child is memoized by useCallback. const getOnClick = useCallback((idx)=>(e)=>{...},[...]); const List = list.map((el,idx)=><Child getOnClick={getOnClick)} idx={idx}/>); const Child = ({getOnClick, idx})=>{<div onClick={getOnclick(idx)}>...</div>} Copy "},{"title":"5. React.cloneElement to pass some props to props.children","type":1,"pageTitle":"React Dev Notes","url":"react/react-dev-detail#5-reactcloneelement-to-pass-some-props-to-propschildren","content":"The resulting element will have the original element’s props with the new props merged in shallowly.original key and ref will be preserved const Wrapper = ({ children }) => { const wrappedChildren = React.cloneElement(children, { ...newProps }); return <>{wrappedChildren}</>; }; Copy "},{"title":"React Interview Questions","type":0,"sectionRef":"#","url":"react/react-interview-questions","content":"","keywords":""},{"title":"Basic","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#basic","content":""},{"title":"1. What is the difference between writing React vs pure javascript","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#1-what-is-the-difference-between-writing-react-vs-pure-javascript","content":"We can definitely output some elements with javascript then append them to the DOM element. However, when talking to update and re-render, manipulating DOM is an expensive operation. React maintain a virtual DOM and do batch update to real DOM after calculating diff in Virtual DOM. "},{"title":"2. explain Class component vs Functional Component","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#2-explain-class-component-vs-functional-component","content":"Class component is stateful, Functional Component is stateless (natively)Debug with Functional Component is easier.Functional Component has more concise code.Functional Component is more suitable for reusing UI.Class component has more live cycleMemoize Class component with React.PureComponentMemoize Functional Component via the memo HOC "},{"title":"3. Explain when will Component re-render?","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#3-explain-when-will-component-re-render","content":"when the reference of props changedif props is a nested object and only inner part change, component will not rerender. "},{"title":"4. useMemo v.s. useCallback ?","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#4-usememo-vs-usecallback-","content":"check Performance Optimization of React "},{"title":"State Management / Redux","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#state-management--redux","content":""},{"title":"4. React.Context v.s. Redux, why don't just use Context","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#4-reactcontext-vs-redux-why-dont-just-use-context","content":"Mainly is because of performance concern.Redux has its own bailout reconciliation mechanism to skip the re-rendering of a component. Context# Context doesn't allow us to use selectors and bailout of rendering. This makes it hard to reduce unnecessary renders and forces you to bend the architecture and reshape the providers all the time.When updating Context, React will recreate new context with Object.assign(), which will never bailout.Every Consumer or component that useContext will be update since the Context is always a new Object.The reason why React does not do reference check of a Context value is, React cannot ensure that developer is using immutable way to update Context. "},{"title":"Memoization","type":1,"pageTitle":"React Interview Questions","url":"react/react-interview-questions#memoization","content":"check Performance Optimization of React Reference# RFC: Context selectors #119深入 React Reconciliation Bailout 機制 "},{"title":"3 Ways To Pass Values From Child to Parent","type":0,"sectionRef":"#","url":"react/react-parent-child-pass-value","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#intro","content":"雖然 React 鼓勵我們提升 state ，將 UI 拆解為小組件，並使用 props 從父組件到子組件傳遞數據。 延伸閱讀: 從 React Prop Drilling 來看 Design Pattern 但在設計流程上，提升 state 其實是有點反設計直覺的，已經設計好的子組件會放到不同父組件內，但總不會一直花時間把它的 state 提升到 Parent，不合成本也會造成 code 的重複，也不會全部 UI state 都交給 redux 處理，總會遇到需要把 state 放在 children，需要再從 children 把更新的資料傳回 parent 的時候，也就是加入反向的資料流，例如這個例子。 簡單記錄幾個用過的方法。 "},{"title":"1. Callback Function","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#1-callback-function","content":"這個方法每次 onChange 都會執行一次。 但要注意如果在 Parent 有執行 setState 的話，Child 也會每次 onChange 就被重新 render，如果考慮到效能的話可以考慮使用第 2 種方法。 const Parent = () => { const [childState,setChildState]=useState(null) const getValue = (v) => {setChildState(v)}; return <Child getValue={getValue} />; }; const Child = ({ getValue }) => { const handleChange=(e)=>{ someThingElse(e); getValue(e.target.value); } return( <input onChange={handleChange} /> )}; } Copy "},{"title":"2. Pass Ref to Child","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#2-pass-ref-to-child","content":"當我們只想要在某些情況(ex.提交表單)時取得 Child 的值，我們可以傳遞 ref 給 Child，需要使用時再從 ref 的 callback ref.current 取得最新的值。這樣不會像第 1 種方法造成 Child 重新 render。 const Parent = () => { const childRef = useRef(null); return ( <> <Child ref={childRef} type='input' /> <button onClick={() => { alert(childRef.current.value); }} > Click Input </button> <Child ref={childRef} type='checkbox'/> <button onClick={() => { alert(childRef.current.checked); }} > Click checkbox </button> <Child ref={childRef} type='select'/> <button onClick={() => { alert(childRef.current); }} > Click checkbox </button> ... </> ); }; const Child = ({ ref,type}) => { switch (type){ case 'input': return <input ref={ref} /> case 'checkbox': return <checkbox ref={ref} /> case 'select': return <select onChange={(v)=>{ref.current=v}} /> ... } } Copy "},{"title":"3. 使用 useImperativeHandle 命令式(不常見)","type":1,"pageTitle":"3 Ways To Pass Values From Child to Parent","url":"react/react-parent-child-pass-value#3-使用-useimperativehandle-命令式不常見","content":"React 官網介紹: Reac.js useImperativeHandle useImperativeHandle customizes the instance value that is exposed to parent components when using ref. As always, imperative code using refs should be avoided in most cases. useImperativeHandle should be used with forwardRef 其實不確定 React 為什麼不建議使用。 這個方法的使用時機是，當 Parent 需要控制 Child 內部的 function，Child 可以把想要對 Parent 暴露的 funciton 放在 useImperativeHandle 中給 Parent 使用。常見用法例如使 Child focus、blur、reset等等。比較不常用在取得 value，不過要用也是可以用，因此也列出來。 codeSandbox import React,{useImperativeHandle,forwardRef,useRef} from \"react\"; const Child = forwardRef((props, ref) => { const childRef = useRef(null); useImperativeHandle(ref, () => ({ forceBlur: () => { inputRef.current.blur(); }, forceReset()=>{ //... }, getValue:()=>childRef.current.value })); return <input ref={childRef} />; }); const Parent = () => { const childRef = useRef(); return ( <> <Child ref={childRef} /> <button onClick={() => { childRef.current.forceBlur(); alert(childRef.current.getValue()); }} > Click </button> </> ); }; Copy "},{"title":"Compound Component","type":0,"sectionRef":"#","url":"react/react-compund-component","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#intro","content":"真實工作上遇到的問題，父組件是一個 Filter ，內部子組件依不同情況會有不同數量的 Input / Select / Radio / CheckBox，並且父組件要能控制子組件的內容(ex.重設等等)，原本的同事是利用 props 傳入 array 去決定 render 什麼內容，但這種方法一來在閱讀上有困難，二來會造成 props 這條路徑同時乘載 UI 內容和資料內容，這樣其實數量多起來閱讀會很混亂，開始思考要如何設計更好。 "},{"title":"What is Compound Component?","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#what-is-compound-component","content":"Compound components is a pattern where components are used together such that they share an implicit state that lets them communicate with each other in the background. A compound component is composed of a subset of child components that all work in tandem to produce some functionality. Compound component 的目的是提供一個更具表現力和靈活的 API，提供了一種表達組件之間關係的好方法。 白話一點來說，也是運用到props.children，父組件只要預設好子組件有哪些(甚至不用)，父組件不需要明確的表達子組件的內容。而是使用時，依不同情境去引入 chidren 的內容即可。 實際上有名的 Material UI和 Semantic UI也都採用了這種 UI 設計方法。 這個教學React Hooks: Compound Components介紹了基本的 Compound Component 設計。 <Toggle onToggle={(on) => console.log(on)}> <Toggle.On>The button is on</Toggle.On> <Toggle.Off>The button is off</Toggle.Off> <Toggle.Button /> </Toggle> Copy "},{"title":"Compound Component 實作: PopupFilter","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#compound-component-實作-popupfilter","content":"現在我們要建立一個 PopupFilter 有以下需求。 我們可以在不同情況下增減子組件。每個子組件都有自己的狀態。要能夠取得/管理子組件的狀態（defaultValue, reset, submit)。 檔案結構： |── PopupFilter ├── index.js ├── components ├── Header └── Footer └── DateRange └── Select └── Checkboxes └── index.js Copy // PopupFilter/index.js import React from 'react'; import { Popper, Grow } from '@material-ui/core'; import { ClickAwayListener } from '@material-ui/core'; import {Header,Select,DateRange,Checkboxes,Footer} from './components'; const PopupFilter = ({ open, anchorEl, children, onClose }) => { return ( <Popper open={open} anchorEl={anchorEl} transition > <div>{children}</div> </Popper> ); }; PopupFilter.Header = Header; PopupFilter.Footer = Footer; PopupFilter.Select = Select; PopupFilter.DateRange = DateRange; PopupFilter.Checkboxes = Checkboxes; export default PopupFilter; //Page.js const Page=()=>{ const [open,setOpen]=React.useState(false); const handleClose=()=>setOpen(false); return( <PopupFilter open={open} onClose={handleClose}> <PopupFilter.Header /> <PopupFilter.Checkboxes label={'CheckBox'} options={...} /> // ... <PopupFilter.Select label={'Select1'} options={...} /> <PopupFilter.Select label={'Select2'} options={...} /> <PopupFilter.DateRange label={'DateRange'} /> <PopupFilter.Footer /> <OtherChildren/> </PopupFilter>) } Copy 好了，看起來其實很簡單，也是使用到 children，讓不同使用情境自行增減，但目前都還沒有考慮到狀態管理的問題。 "},{"title":"狀態管理 State Management","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#狀態管理-state-management","content":"現在，子組件並未受到父組件控制。 我們要如何管理子組件的 state（ex. defaultValue，handleChange，handleReset，getResult ...）？因為這種做法父組件不會提前知道子組件有什麼內容，所以也無法預設有多少個子組件的 state 要管理。其實是比父組件更上層的頁面組件才會知道當下子組件有多少個。 "},{"title":"1. 把 state 都放在頁面組件裡","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#1-把-state-都放在頁面組件裡","content":"這是最直覺的，lift state up，但是當組件增加時頁面就會變得混亂。結果將會出現一堆狀態和 handleChange。 2. Custom hook# 將 state / update/ reset 的邏輯放在 hook 裡，我們將其稱為 usePopupFilter。 那回到剛剛的問題，要如何動態的幫子組件建立 state 呢？我們可以讓 usePopupFilter return 一個 register 的方法 \b，每個需要控制狀態的子組件提供不重複的 key，使用 register 來註冊自己在 state 中的位置。 在頁面中，我們只是使用 custom hook 取得結果的最新狀態，保持頁面的簡潔和可讀性，既優雅又簡潔。 //usePopupFilter.js import { useState, useEffect, useCallback } from \"react\"; import { useImmer } from \"use-immer\"; const usePopupFilter = ({ defaultValue }) => { const [state, setState] = useState({ data: { ...defaultValue } }); const { data } = state; //提供子組件「註冊」一個state Object的key欄位，並回傳子組件需要的prop const register = useCallback( (key) => ({ value: data[key], defaultValue: defaultValue[key], onChange: (value) => setState((state) => (state.data[key] = value)), }), [data] ); //提供onSubmit傳入並讀取data const handleSubmit = useCallback( (onSubmit) => () => { onSubmit(data); }, [data] ); const reset = useCallback(() => { setState((state) => (state.data = defaultValue)); }, []); return { state, register, handleSubmit, reset }; }; export default usePopupFilter; Copy "},{"title":"實際使用","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#實際使用","content":"import React, { useState, useEffect } from 'react'; import PopupFilter from './PopupFilter'; import usePopupFilter from 'Hooks/usePopupFilter'; export const PopupFilterDemo = () => { const [open, setOpen] = useState(false); const { state, register, handleSubmit, reset } = usePopupFilter({ defaultValue: { checkbox: [options1[1]], }, ... }); const handleOpen = () => { setOpen(!open); }; const handleClose = () => setOpen(false); const onFilter = data => { handleClose(); handleSubmit_(); }; const handleSubmit_=()=>{ ... } return ( <div > <button onClick={handleOpen}>OpenFilter</button> <PopupFilter open={open} onClose={handleClose}> <PopupFilter.Header onClick={reset} /> <PopupFilter.Checkboxes label={'CheckBox'} options={options1} {...register('checkbox')} /> <PopupFilter.Select label={'Select'} options={options2} {...register('select')} /> <PopupFilter.Select label={'Select2'} options={options2} {...register('select2')} /> <PopupFilter.DateRange label={'DateRange'} {...register('DateRange')} /> <PopupFilter.Footer onClick={handleSubmit(onFilter)} /> </PopupFilter> </div> ); }; const options1 = [ { value: '1', label: 'option1' }, { value: '2', label: 'option2' }, { value: '3', label: 'option3' }, ]; const options2 = [ { value: '1', label: 'select1' }, { value: '2', label: 'select2' }, { value: '3', label: 'select3' }, ]; Copy "},{"title":"Reference","type":1,"pageTitle":"Compound Component","url":"react/react-compund-component#reference","content":"React Hooks: Compound ComponentsMaster the Compound Component PatternReact.js Building Your Own Hooks "},{"title":"Performance Optimization of React","type":0,"sectionRef":"#","url":"react/react-performance-optimization","content":"","keywords":""},{"title":"Keeping component state local where necessary","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#keeping-component-state-local-where-necessary","content":""},{"title":"Memoization","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#memoization","content":"Reduce unnecessary re-render of a component "},{"title":"Why do they need to memo?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#why-do-they-need-to-memo","content":"If component is large or there is heavy computation in component, re-render becomes expensive. We already know Reat "},{"title":"What do they memo?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#what-do-they-memo","content":"HOF# memo: a (wrapped) Component PureComponent: a class component Hook# useCallback: a function (in component)useMemo: a value (in component)useRef: a value (in component) "},{"title":"When do they trigger re-render?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#when-do-they-trigger-re-render","content":"memo: only when equality function returns truePureComponent: when previous prop does not equal to next prop with shallow comparison.useCallback: only when dependency list changeuseMemo: only when dependency list changeuseRef: will not trigger re-render "},{"title":"Ways to Memoize a constant / Object","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#ways-to-memoize-a-constant--object","content":"declare outside component If the value is irrelevant to props, just declare outside component.useMemo: const memoizedValue = useMemo(objFromProps,[dependencies])useRef: const memoizedValue = useRef(objFromProps)p.s. useMemo(initialValue,[]) works same as useRef(initialValue) "},{"title":"Ways to Memoize a function","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#ways-to-memoize-a-function","content":"declare outside component If the function is irrelevant to props, just declare outside component.const memoizedFunction = useCallback(funcFromProps,[dependencies]) "},{"title":"How to Prevent unnecessary re-render of a component","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#how-to-prevent-unnecessary-re-render-of-a-component","content":"useCallback in parent to memoize method props.useMemo to memoize non-primitive-type value.Wrap component with React.memo and check the equality of props.Use PureComponent for class component "},{"title":"Declare function & constant outside vs inside component ?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#declare-function--constant-outside-vs-inside-component-","content":"Outside component: will not be re-created on every render.Inside component: will be re-created on every render. "},{"title":"Code-splitting in React using dynamic import()","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#code-splitting-in-react-using-dynamic-import","content":"const Home = React.lazy(() => import(\"./components/Home\")); <React.Suspense fallback={<p>Loading page...</p>}> <Route path=\"/\" exact> <Home /> </Route> <Route path=\"/about\"> <About /> </Route> </React.Suspense> Copy  "},{"title":"How to Inspect performance ?","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#how-to-inspect-performance-","content":""},{"title":"Chrome DevTools Performance","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#chrome-devtools-performance","content":""},{"title":"React Profiler","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#react-profiler","content":"Install React Developer ToolsOpen Chrome Devtools -> [Profiler] TabSettings -> General -> [v] Highlight updates when components render. "},{"title":"Profiler API","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#profiler-api","content":"import React, { Profiler } from \"react\"; const CustomStockChart = (props) => { // ... return ( <Profiler id=\"StockChart\" onRender={logTimes}> <StockChart>{/* ... */}</StockChart> </Profiler> ); }; const logTimes = (id, phase, actualTime, baseTime, startTime, commitTime) => { console.log(`${id}'s ${phase} phase:`); console.log(`Actual time: ${actualTime}`); console.log(`Base time: ${baseTime}`); console.log(`Start time: ${startTime}`); console.log(`Commit time: ${commitTime}`); }; export default CustomStockChart; Copy "},{"title":"Meaning of Profiling value","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#meaning-of-profiling-value","content":"id: string - The id prop of the Profiler tree that has just committed. This can be used to identify which part of the tree was committed if you are using multiple profilers. phase: \"mount\" | \"update\" - Identifies whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks. actualDuration: number - Time spent rendering the Profiler and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. React.memo, useMemo, shouldComponentUpdate). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change. baseDuration: number - Duration of the most recent render time for each individual component within the Profiler tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). "},{"title":"Reference","type":1,"pageTitle":"Performance Optimization of React","url":"react/react-performance-optimization#reference","content":"A Closer Look at React Memoize Hooks: useRef, useCallback, and useMemoIntroducing the React Profiler使用 React Profiler 來觀察 React Web App 的渲染狀況並進行效能優化Chrome: Performance features reference "},{"title":"Props Drilling and State Management","type":0,"sectionRef":"#","url":"react/react-prop-drilling","content":"","keywords":""},{"title":"What is Prop Drilling?","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#what-is-prop-drilling","content":"Many articles see prop drilling is a problem.But it is actually an design pattern.Remind that when we first learn React, we learned: Lifting State Up Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. This is one of the design patterns for state management "},{"title":"Pros of Prop Drilling","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#pros-of-prop-drilling","content":"good for reusing UIno extra abundanceeasy for pros tracing  "},{"title":"Why is Prop Drilling a Problem","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#why-is-prop-drilling-a-problem","content":"Think about below scenario. ComponentNeedingProps is the component who really need contentComponentNeedingProps is deeply nested inside FirstComponent, SecondComponent and ThirdComponent while they three don't actually need contentWhen there are more of these kind of prop, it brings difficulties on maintaining code. export default function App() { return ( <div className=\"App\"> <FirstComponent content=\"Who needs me?\" /> </div> ); } function FirstComponent({ content }) { return ( <div> <h3>I am the first component</h3>; <SecondComponent content={content} />| </div> ); } function SecondComponent({ content }) { return ( <div> <h3>I am the second component</h3>; <ThirdComponent content={content} /> </div> ); } function ThirdComponent({ content }) { return ( <div> <h3>I am the third component</h3>; <ComponentNeedingProps content={content} /> </div> ); } function ComponentNeedingProps({ content }) { return <h3>{content}</h3>; } Copy "},{"title":"Solutions","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#solutions","content":""},{"title":"1. Pass component in props.children","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#1-pass-component-in-propschildren","content":"props.children is an attribute returns by React.createElement​. It refers to child node.We can pass contents like HTML tag、component down to child componentwe just hide the pros drilling inside children.Reference: Children in JSX function App() { const content = \"Who needs me?\"; return ( <div className=\"App\"> <FirstComponent> <SecondComponent> <ThirdComponent> <ComponentNeedingProps content={content} /> <ThirdComponent> </SecondComponent> </FirstComponent> </div> ); } //rewrite function FirstComponent({ content }) { return ( <div> <h3>I am the first component</h3>; {children} </div> ); } Copy "},{"title":"2. Context API","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#2-context-api","content":"Using Context API to Context.Consumer and render it with render props方式接收。Another design pattern: Provider Pattern。 export default function App() { return ( <div className=\"App\"> <Context.Provider value={content}> <FirstComponent content=\"Who needs me?\" /> </Context.Provider> </div> ); } function ComponentNeedingProps() { const content = Context.Consumer; return <Context.Consumer>{(content) => <h3>{content}</h3>}</Context.Consumer>; } Copy "},{"title":"3. State management tools ex.Redux, Mobx...","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#3-state-management-tools-exredux-mobx","content":" "},{"title":"Redux v.s. Context API","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#redux-vs-context-api","content":"Why don't we just replace Redux with native Context? "},{"title":"Same","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#same","content":"both are for state managementboth to avoid props drilling "},{"title":"Redux","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#redux","content":"Redux construct an global 的 store to store all state.Redux is single data flow (FLUX)Redux update store with action(constant) and reducer (pure function)react-redux: every component inside Provider can use connect HOF or useSelector hook to subscribe to some part of the state. Pros# provide middleware-friendly API to let you do something between action and reducer, (ex. redux-thunk, redux-saga)good definition based on FLUX: store/reducer/actionuseSelector hook to subscribe state change。 Cons# more dependencymore definition and naming (action,reducer) "},{"title":"React Context API","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#react-context-api","content":"hooks: createContext, useContext# Pros# native in React, no extra dependencyflexiblecan use multiple Provider state Cons# too little definition, may cause difference in codes.When a context value is changed, all components that useContext will re-render. When the nearest MyContext.Provider above the component updates, this Hook will trigger a re-render with the latest context value passed to that MyContext provider. Even if an ancestor uses React.memo or shouldComponentUpdate, a re-render will still happen starting at the component itself using useContext. Update 2021: use-context-selector# is currently developinguseContextSelector: This hook returns context selected value by selector.It will only accept context created by createContext. It will trigger re-render if only the selected value is referentially changed. "},{"title":"Conclusion","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#conclusion","content":"Redux is still an popular state management solution for large applications.if in smaller application or performance is not an issue, Context could be a good solution too.they can be used together  "},{"title":"reference","type":1,"pageTitle":"Props Drilling and State Management","url":"react/react-prop-drilling#reference","content":"How To Avoid Prop Drilling in React Using Component CompositionReact 狀態管理模式 "},{"title":"Redux and Flux","type":0,"sectionRef":"#","url":"react/redux-flux","content":"","keywords":""},{"title":"Flux","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#flux","content":"Video Hacker Way: Rethinking Web App Development at FacebookFlux is more an application architecture / design pattern than a framework.Redux is one kind of implementation of Flux. "},{"title":"Flux Architecture","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#flux-architecture","content":" "},{"title":"Flux and Redux","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#flux-and-redux","content":" "},{"title":"Why Flux?","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#why-flux","content":"MVC doesn't scale, it becomes unpredictable when scaling because: data flow in MVC tend to be difficult to understand, to trace bug Flux use unidirectional data flow: action -> store -> view for more understandable mental model than MVC.Flux internalize the control into view: so that state is very next to the logic of state update, easier to maintain consistency.Flux structure helps separate view state from data "},{"title":"Benefits of Flux","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#benefits-of-flux","content":"Improve data consistencyEasier to pinpoint a bug "},{"title":"Stores","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#stores","content":"Do: listen to action ( bindListeners in alt.js)performs state update based on action payload (reducer in redux)manage the state of many objectsbroadcast an event declaring that their state has changed "},{"title":"Controller-Views","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#controller-views","content":"Do: listen to the changes from store and re-renderget the data from the storespass this data down the chain of its descendants  "},{"title":"Extension","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#extension","content":""},{"title":"Store: Singleton Pattern","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#store-singleton-pattern","content":"Singleton Pattern is a design pattern that restricts the instantiation of a class to one object. There is only one state tree known as Store in Redux.Store is Single source of truth. "},{"title":"Connect/Selector: Observer Pattern","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#connectselector-observer-pattern","content":"An object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes. "},{"title":"applyMiddleware: Decorator Pattern / HOF","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#applymiddleware-decorator-pattern--hof","content":"designed to enhance functionality, but does not change the interface "},{"title":"Reference","type":1,"pageTitle":"Redux and Flux","url":"react/redux-flux#reference","content":"FluxAn introduction to the Flux architectural patternAn Obsession with Design Patterns: ReduxDifference between redux and flux "},{"title":"Web Authentication","type":0,"sectionRef":"#","url":"web-dev/web-auth","content":"","keywords":""},{"title":"Session Based Authentication","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#session-based-authentication","content":" In the session based authentication, the server will create a session for the user after the user logs in. The session id is then stored on a cookie on the user’s browser. While the user stays logged in, the cookie would be sent along with every subsequent request. The server can then compare the session id stored on the cookie against the session information stored in the memory to verify user’s identity and sends response with the corresponding state! "},{"title":"Token Based Authentication: JWT (JSON Web Tokens)","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#token-based-authentication-jwt-json-web-tokens","content":" "},{"title":"Purpose","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#purpose","content":"It is generally used to pass authenticated user identity information between the auth provider and the service provider in order to obtain resources from the resource server. It is usually suitable for the scenario one-time authorization, cross domain auth "},{"title":"Content","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#content","content":"composed of: base64(Header) + base64(Payload) + base64(Signature) Header# The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC, SHA256 or RSA. { \"alg\": \"HS256\", \"typ\": \"JWT\" } Copy Payload# Payload contains the claims. Claims are statements about an entity (typically, the user) and additional data. for local use: symmetric digital signature algorithm: use same secrete key to sign and verifyfor public use: asymmetric digital signature algorithm: use private key to sign token and public key to verify token. Signature# The signature is used to verify the message wasn't changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is. "},{"title":"Cons","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#cons","content":"Cannot proactively expires token. Prone to trivial token forgery: Send a header that specifies the none algorithm be usedSend a header that specifies the HS256 algorithm when the application normally signs messages with an RSA public key. HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), 'secret') Copy "},{"title":"Reference","type":1,"pageTitle":"Web Authentication","url":"web-dev/web-auth#reference","content":"jwt.io不要用 JWT 替代 session 管理（上）：全面了解 Token,JWT,OAuth,SAML,SSO "},{"title":"Browser Navigation Flow","type":0,"sectionRef":"#","url":"web-dev/web-browser-navigation-flow","content":"","keywords":""},{"title":"Review Browser Architecture","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#review-browser-architecture","content":" "},{"title":"Browser Process","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#browser-process","content":"consists of# UI threadnetwork thread control# Chrome part of the application including address bar, bookmarks, back and forward buttons. "},{"title":"Renderer Process","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#renderer-process","content":"consists of# Main threadworker thread control# anything inside of the tab where a website is displayed. "},{"title":"GPU Process(s)","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#gpu-processs","content":"Control# Handles GPU tasks in isolation from other processes. "},{"title":"Reference","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#reference","content":"Which process controls what?  "},{"title":"What happens when we visit google.com?","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#what-happens-when-we-visit-googlecom","content":""},{"title":"W3C 5.1 Processing Model","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#w3c-51-processing-model","content":"This illustration is non-normative. The following graph illustrates the timing attributes defined by the PerformanceTiming interface and the PerformanceNavigation interface with or without redirect, respectively. Attributes underlined may not be available in navigation involving documents from different origins. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.  "},{"title":"Browser process: Handling Input","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#browser-process-handling-input","content":"Handling Input: UI thread needs to parse and decide whether to send you to a search engine, or to the site you requested.Start navigation:UI thread initiates a network call to get site content.DNS Lookup: network thread initiates DNS lookup. "},{"title":"DNS lookup","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#dns-lookup","content":"Check Cache: Browser check browser’s local cache and computer's DNS cache if there is already IP address saved.If No Cache, the query travels into the Internet and is received by a DNS recursive resolver.The resolver then queries a DNS root nameserver (.).The root server then responds to the resolver with the address of a Top Level Domain (TLD) DNS server (such as .com or .net), which stores the information for its domains. When searching for example.com, our request is pointed toward the .com TLD.The resolver then makes a request to the .com TLD.The TLD server then responds with the IP address of the domain’s nameserver, example.com.Lastly, the recursive resolver sends a query to the domain’s nameserver.The IP address for example.com is then returned to the resolver from the nameserver.The DNS resolver then responds to the web browser with the IP address of the domain requested initially. "},{"title":"Network Thread: Make Request","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#network-thread-make-request","content":"Once the 8 steps of the DNS lookup have returned the IP address for example.com, the browser is able to make the request for the web page: Browser setup TCP connection to the server via a TCP three-way handshake. For HTTPS connection, another TLS Handshake is required Browser sends an initial HTTP GET request to the IP address.Server send HTTP response with meta info in header to Browser.Browser receives the response header and content. #Time to First ByteBrowser check Content-Type header to determine the type of data. if Content-Type header is missing or wrong, MIME Type sniffing is done here. Browser stores cookie, and make request for css or jsNetwork Thread tells UI thread that the data is ready.UI thread finds a renderer process to continue rendering. Meanwhile UI thread updates the UI of browser (ex. url bar, security indicator)The session history for the tab will be updated "},{"title":"Renderer Process: Rendering","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#renderer-process-rendering","content":"check detail about Critical Rendering Path Img: Navigation Timing API#  Img: Rendering Process#  domLoading event: main thread Parse HTML and Construct DOM tree.Download resource: such as images, CSS, and JavaScript preload scanner sends requests to the network thread.JavaScript compilation: JavaScript is interpreted, compiled, parsed and executed. The scripts are parsed into abstract syntax trees domInteractive event: DOM tree is constructed.main thread Parse CSS, Calculate style to Construct CSSOM tree/computed styledomContentLoaded: DOM tree and CSSOM tree both constructed. Normally Javascript start executing on this event. main thread going over DOM tree with computed styles and producing layout treemain thread walks the layout tree to create paint records Paint record is a note of painting process like \"background first, then text, then rectangle\". "},{"title":"Paint","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#paint","content":""},{"title":"Compositing","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#compositing","content":"because sections of the document are drawn in different layerslayer tree is created and paint orders are determinedmain thread commits that information to the compositor threadThe compositor thread then rasterizes each layer. A layer could be large like the entire length of a page, so the compositor thread divides them into tiles and sends each tile off to raster threads.Raster threads rasterize each tile and store them in GPU memory. "},{"title":"Reflow","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#reflow","content":"As the page continues to load assets, reflows can happenA reflow sparks a repaint and a re-composite.  "},{"title":"Service Worker","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#service-worker","content":"TBC... "},{"title":"Reference","type":1,"pageTitle":"Browser Navigation Flow","url":"web-dev/web-browser-navigation-flow#reference-1","content":"W3C: navigation timingInside look at modern web browser (part 2)Inside look at modern web browser (part 3)What Is DNS? | How DNS WorksCritical Rendering Path使用 Navigation Timing 評估關鍵轉譯路徑MDN: how browsers work "},{"title":"JS engine: Introduction","type":0,"sectionRef":"#","url":"web-dev/web-js-engine-introduction","content":"","keywords":""},{"title":"Main Javascript Engines","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#main-javascript-engines","content":"Chrome/Google: V8FireFox/Mozilla: SpiderMonkeyEdge/Microsoft: used to be Chakra / now v8Safari/Apple: JavaScriptCore "},{"title":"Javasciprt Engine Pipeline","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#javasciprt-engine-pipeline","content":" JS Engines runs with this similiar pipeline but different in optimization process. "},{"title":"Process","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#process","content":"parse javascript into Abstract Syntax Tree (AST)interpreter generate byte codeOptimization start!bytecode is sent to the optimizing compiler along with profiling data.optimizing compiler makes assumption then produces highly-optimized machine code based on profiling dataIf the assumptions turns out to be incorrect, the optimizing compiler deoptimizes and goes back to the interpreter. "},{"title":"Trade off","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#trade-off","content":""},{"title":"Startup Speed","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#startup-speed","content":" interpreter: produce bytecode quickly, produces inefficient machine code.optimizing compiler: takes longer, produces efficient machine code. "},{"title":"Memory","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#memory","content":" optimized machine code also requires more memory. "},{"title":"Note","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#note","content":"Initialize object props with sensible values.always initialize objecs in the same way.type checking is about developer productivity but not about engine performance "},{"title":"Reference","type":1,"pageTitle":"JS engine: Introduction","url":"web-dev/web-js-engine-introduction#reference","content":"JavaScript engine fundamentals: optimizing prototypesJavaScript engine fundamentals: Shapes and Inline CachesMathias B, Benedikt M - JS Engine fundamentals [AgentConf] "},{"title":"Node.js Streaming Server-Side Rendering","type":0,"sectionRef":"#","url":"web-dev/ssr-stream","content":"","keywords":""},{"title":"TL:DR","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#tldr","content":"React can be a lost faster than client side rendering.Straming enables page performance to stay constant.We need to think our page as separately renderable pieces.The scenario is usually high performance server and lower performace client browser/device and slow network "},{"title":"Review the rendering work flow","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#review-the-rendering-work-flow","content":" "},{"title":"Intro - Different Types of Rendering Flow","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#intro---different-types-of-rendering-flow","content":" see more on Rendering on the Web "},{"title":"1. Client Side Rendering","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#1-client-side-rendering","content":" client requestserver returns small html with no infoclient request doc header and request JS and CSSclient parse JS & CSSclient browser painting meanwhile request for data from APIAPI returns dataclient use ReactDOM.render() to revive the DOM once you have both Javascript and JSON dataclient shows full page and become interactive Pros and Cons# pros: no need dynamic servercons: slow cuz jobs are done in serialcons: slow cuz parsing javascript is expensive "},{"title":"2. Server Side Rendering","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#2-server-side-rendering","content":" client requestserver return only HTML header to clientclient request for JS and CSS based on HTML headerserver meanwhile make request to API serverserver load data on the server side and use ReactDOMServer.renderToString() to create HTML markupclient parsing JS and CSSserver send the data down in a script tag or via HTTP/2 Server Push. (first contentful paint)client become interactive when step 6 is done (Time to Interactive) noted that: 3 and 4 can be parallel5 and 6 can be parallel Pros and Cons# pros: faster than client side rendering cuz job can be done in parallelpros: faster than client side rendering cuz server usually has better performance than clientcons: needs dynamic web servercons: Don't scale, Time to Interactive increase when more feature (JS and CSS) added on page.  "},{"title":"Terms","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#terms","content":""},{"title":"flush()","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#flush","content":"A res.flush method is added to force partially compressed response to be flushed to the client. "},{"title":"React.hydrate()","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#reacthydrate","content":"Same as render(), but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup. "},{"title":"Rehydration","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#rehydration","content":"“booting up” JavaScript views on the client such that they reuse the server-rendered HTML’s DOM tree and data. "},{"title":"ReactDOMServer.renderToNodeStream(element)","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#reactdomserverrendertonodestreamelement","content":"Returns a Readable stream that outputs an HTML string.The HTML output by this stream is exactly equal to what ReactDOMServer.renderToString would return.The function will only work on the server to render HTML as a stream.The client receiving this stream can subsequently call ReactDOM.hydrate() to hydrate the page and make it interactive.  "},{"title":"Streaming SSR","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#streaming-ssr","content":"streaming implies chunks of HTML are streamed from the node server to the client as they are generated.we need to break down each part of the page and send them to client respectivelyoverall process seems like multiple chunks of normal SSRs.can combine with progressive hydration to increase Time to Interactive on client side "},{"title":"Normal SSR (top) v.s. Streaming SSR (bottom)","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#normal-ssr-top-vs-streaming-ssr-bottom","content":" "},{"title":"Pros & Cons","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#pros--cons","content":"pros: Fastest First Contentful Paint, fastest Time to Interactivepros: As the page scales up in content and JS, above the fold load stays constant.pros: More fault tolerant of misbehaving data service further down the page.pros: Streaming enables Node.js server to render multiple requests at the same time and prevents heavier requests from blocking lighter requests for a long time.cons: intra-page code splitting is complicatedcons: webpack doesn't yet support multiple CSS chunks for one entry chunk (2017 video, need to check)cons: tricky to implement perfect optimization of resource loading "},{"title":"Example: GoogleChromeLabs/progressive-rendering-frameworks-samples","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#example-googlechromelabsprogressive-rendering-frameworks-samples","content":"react-streaming-ssr/app/server.js# import React from \"react\"; import ReactDOMServer from \"react-dom/server\"; import App from \"./components/app\"; export default async function ssr({ streaming, ...props }) { if (streaming) { return ReactDOMServer.renderToNodeStream(<App {...props} />); } else { return ReactDOMServer.renderToString(<App {...props} />); } } Copy react-streaming-ssr/server.js# app.get(\"/streaming\", async (request, response) => { try { const stream = await ssr({ url: request.url, }); // Wait until data starts flowing to send a 200 OK, // so errors don't trigger \"headers already sent\". const start = Date.now(); stream.on(\"data\", function handleData() { console.log(\"Render Start: \", Date.now() - start); stream.off(\"data\", handleData); response.useChunkedEncodingByDefault = true; response.writeHead(200, { \"content-type\": \"text/html\", \"content-transfer-encoding\": \"chunked\", \"x-content-type-options\": \"nosniff\", }); response.write(BEFORE); response.flushHeaders(); }); await new Promise((resolve, reject) => { stream.on(\"error\", (err) => { stream.unpipe(response); reject(err); }); stream.on(\"end\", () => { console.log(\"Render End: \", Date.now() - start); response.write(\"</div></body></html>\"); response.end(); resolve(); }); stream.pipe(response, { end: false }); }); } catch (err) { response.writeHead(500, { \"content-type\": \"text/pain\", }); response.end(String((err && err.stack) || err)); return; } }); Copy  "},{"title":"Progressive Hydration","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#progressive-hydration","content":"Purpose: to partially hydrate the content on the client or to prioritize the content that needs to be hydrated.One popular way to achieve this is to wrap your component in the Intersection Observer "},{"title":"Pros","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#pros","content":"Reduce first Time-To-Interact on the client-side.Reduce first paint time on the client-side.Serve content faster to the user without the user noticing any difference. "},{"title":"Example: progressive-hydration","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#example-progressive-hydration","content":"react-progressive-hydration/app/components/hydrator.js export class Hydrator extends React.Component { shouldComponentUpdate() { return false; } componentDidMount() { new IntersectionObserver(async ([entry], obs) => { if (!entry.isIntersecting) return; obs.unobserve(this.root); const { load, ...props } = this.props; const Child = interopDefault(await load()); ReactDOM.hydrate(<Child {...props} />, this.root); }).observe(this.root); } render() { return ( <section ref={(c) => (this.root = c)} dangerouslySetInnerHTML={{ __html: \"\" }} suppressHydrationWarning /> ); } } Copy react-progressive-hydration/app/components/app.js export default function App() { return ( <div id=\"app\"> <Header /> <Intro /> {/* <Stream flush={flushing} /> */} <Hydrator load={load} /> </div> ); } Copy  "},{"title":"Ndoe.js Stream","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#ndoejs-stream","content":"Stream Into the Future (NodeJS Streams) All You Need To Know About Node JS Stream In Detail //TODO "},{"title":"Reference","type":1,"pageTitle":"Node.js Streaming Server-Side Rendering","url":"web-dev/ssr-stream#reference","content":"Rendering on the WebStreaming Server-Side RenderingHow Streaming Can Supercharge React - Sasha Aickin aka @xander76 at ReactEurope 2017Stream Into the Future (NodeJS Streams)All You Need To Know About Node JS Stream In Detail "},{"title":"JS engine: Optimizing of Object","type":0,"sectionRef":"#","url":"web-dev/web-js-engine-object-optimization","content":"","keywords":""},{"title":"TL;DR","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#tldr","content":"Javascript objects are dictionaries essentially, but engines use Shape internally to optimize it.Prototypes are just objects, but Javascript Engine treate them specially.Do not mess with Prototypes, it hurts performance because the. "},{"title":"JavaScript’s object model","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#javascripts-object-model","content":""},{"title":"How JavaScript defines objects.","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#how-javascript-defines-objects","content":" The ECMAScript specification essentially defines all objects as dictionaries, with string keys mapping to property attributes. [[Writable]]: whether the property can be reassigned to. [[Enumerable]]: whether the property shows up in for-in loops. [[Configurable]]:whether the property can be deleted. We can see these properties with const object = { foo: 42 }; Object.getOwnPropertyDescriptor(object, \"foo\"); // → { value: 42, writable: true, enumerable: true, configurable: true } Copy  "},{"title":"How are these these property attributes actually stored in memory?","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#how-are-these-these-property-attributes-actually-stored-in-memory","content":""},{"title":"Shape as Optimization","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#shape-as-optimization","content":"If we assume that we’ll be seeing more objects with this shape later, then it’s wasteful to store the full dictionary containing the property names and attributes on the JSObject itself, as the property names are repeated for all objects with the same shape. That’s a lot of duplication and unnecessarily memory usage. As an optimization, engines store the Shape of the object separately. No matter how many objects there are, as long as they have the same shape, we only have to store the shape and property information once!  This Shape contains all the property names and the attributes, except for their [[Value]]s.Every JSObject with this same shape points to exactly this Shape instance.Offset: record the offset of the values inside of the JSObject so JavaScript engine knows where to find the values. "},{"title":"Naming","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#naming","content":"All JavaScript engines use shapes as an optimization, but they don’t all call them shapes.Academic papers: Hidden Classes (confusing w.r.t. JavaScript classes)V8: Maps (confusing w.r.t. JavaScript Maps)Chakra: Types (confusing w.r.t. JavaScript’s dynamic types and typeof)JavaScriptCore:StructuresSpiderMonkey:Shapes  "},{"title":"What happens if you have an object with a certain shape, but then you add a property to it?","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#what-happens-if-you-have-an-object-with-a-certain-shape-but-then-you-add-a-property-to-it","content":""},{"title":"Transition Chain","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#transition-chain","content":"The shapes form so-called transition chains in the JavaScript engine. const object = {}; object.x = 5; object.y = 6; Copy  Transition Chains are link list, every Shape links back to its previous shape.Every time we add new properties in Object, JavaScript engine transitions to a new shape which only needs to know about the new property it introduces. In this case the Shape(x,y) pointThe order in which properties are added impacts the shape. For example, { x: 4, y: 5 } results in a different shape than { y: 5, x: 4 }  "},{"title":"Inline Caches (ICs)","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#inline-caches-ics","content":"ICs: memorize information on where to find properties on objects, to reduce the number of expensive lookups.ICs are the key ingredient to making JavaScript run fast! "},{"title":"Note","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#note","content":"Initialize object props with sensible values.always initialize objecs in the same way.type checking is about developer productivity but not about engine performance "},{"title":"Reference","type":1,"pageTitle":"JS engine: Optimizing of Object","url":"web-dev/web-js-engine-object-optimization#reference","content":"JavaScript engine fundamentals: optimizing prototypesJavaScript engine fundamentals: Shapes and Inline CachesMathias B, Benedikt M - JS Engine fundamentals [AgentConf]The story of a V8 performance cliff in React "},{"title":"Lighthouse Performance / Frontend Performance","type":0,"sectionRef":"#","url":"web-dev/web-lighthouse-performance","content":"","keywords":""},{"title":"Intro","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#intro","content":"如何定義一個好的網頁？LightHouse下的網頁評分標準有四項： PerformanceBest PracticesSEOAccessibility 本次紀錄主要探討 Performance 部分。 "},{"title":"TOOLS","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#tools","content":"PageSpeed InsightsGTmetrixChrome Devtool Performance "},{"title":"Concept","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#concept","content":""},{"title":"Critical Rendering Path","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#critical-rendering-path","content":"Download Resource#  第一次往返: 傳輸 html。第二次-第 N 次往返: 傳輸 CSS 和 JS。 Rendering Process#  頁面要等到 DOM 和 CSSOM 都解析完後，才會 render 出畫面。 Terms# 關鍵資源/禁止轉譯資源：可能禁止網頁初次轉譯的資源。 CSS 預設為禁止轉譯(render blocking)，也就是 CSSOM 還未建構完成前，瀏覽器不會進行轉譯。「禁止轉譯」僅指該資源是否會阻止瀏覽器初次轉譯網頁。無論是否禁止，瀏覽器仍會下載 CSS，只是優先順序較低。 關鍵路徑長度：即往返過程數量，或擷取所有關鍵資源所需的總時間。關鍵位元組：實現網頁初次轉譯所需的總位元組數，這是所有關鍵資源的傳輸檔案大小總和。  "},{"title":"Performance Metrics","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#performance-metrics","content":"based on Lighthouse V6  "},{"title":"FCP (First Contentful Paint) 首次內容繪製","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#fcp-first-contentful-paint-首次內容繪製","content":"當瀏覽者到達網站之後，首次顯示 DOM 內容需要的時間。FCP = TTFB(Time to First Byte) + Content Load Time + Render Time "},{"title":"SI (Speed Index) 速度指數","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#si-speed-index-速度指數","content":"速度指數會以「網頁可見內容填入速度」計算，也就是以眼睛可以看到的圖像去計算分數。因素: html+CSS Frame[i] = interval time*(1 – visual complete %/100) SI score = Frame[1]+...+Frame[n] Copy "},{"title":"TTI (Time to Interactive) 可互動時間","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#tti-time-to-interactive-可互動時間","content":"「網頁進入完整互動狀態前」花費的時間，簡單來說網站要全部載入才能開始閱讀、互動。因素: HTML+CSS+圖片+JavaScript "},{"title":"LCP (Largest Contentful Paint) 最大內容繪製","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#lcp-largest-contentful-paint-最大內容繪製","content":"最大的文字、圖片或是影片呈現到眼前所需要的時間。因素: 文字+圖片 "},{"title":"CLS (Cumulative Layout Shift) 累計版面配置轉移","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#cls-cumulative-layout-shift-累計版面配置轉移","content":"測量可見元素在可視區域內的移動情形，當網站讀取過慢，正要點的時候按鈕(物件)忽然跑掉造成點錯位置，越少越好。常見原因: 沒有圖框包圍的圖像沒有尺寸的廣告或嵌入式 iframe動態注入的內容 "},{"title":"TBT (Total Blocking Time) 封鎖時間總計","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#tbt-total-blocking-time-封鎖時間總計","content":"當工作長度超過 50 毫秒時，從 FCP 到 TTI 之間，準備時間的時間範圍總計，延遲越久分數越低。因素:FCP、TTI、SI。 "},{"title":"FID (First Input Delay 首次輸入延遲","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#fid-first-input-delay-首次輸入延遲","content":"測量互動性的速度，為了提供良好的用戶體驗，網頁的 FID 應當小於 100 毫秒，像是點擊(Click)。無論是點擊連結、影片、圖片，只要點下去反應很慢的，慢到以為網站故障、無作用，就是「首次輸入的延遲」。  "},{"title":"Optimization","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#optimization","content":""},{"title":"PRPL pattern","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#prpl-pattern","content":"Push (or preload) the most important resources.Render the initial route as soon as possible.Pre-cache remaining assets.Lazy load other routes and non-critical assets. "},{"title":"HTML","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#html","content":"Optimization# 僅在需要時創建 node，銷毀不需要的 node不要用 CSS 隱藏不要過多層的 div "},{"title":"CSS","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#css","content":"CSS 預設為禁止轉譯，也就是 CSSOM 還未建構完成前，瀏覽器不會進行轉譯。過多的禁止轉譯 CSS 會影響 FCP, TTI 等效能指數。 Optimization# inline/preload critical CSSdefer non-critical CSS <link rel=\"preload\" as=\"style\" href=\"async_style.css\" onload=\"this.rel='stylesheet'\" /> <noscript><link rel=\"stylesheet\" href=\"[yourcssfile]\" /></noscript> Copy CSS import 會增加往返次數/影響效能Webpack CSS bundle Size "},{"title":"Javascript","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#javascript","content":"若首次載入時沒有需要 JS 才能顯示的部分，則 JS 理論上不影響 FCP (E.g. SSR or pure HTML)SPA architecture relies on JS for rendering Optimization# script tag with defer or async for lazy loading JSInline Critical Resources, Defer Non-Critical Resources, Remove Anything UnusedWebpack JS bundle SizeLazy Loading , Code Splitting "},{"title":"Framework / React","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#framework--react","content":"Performance Optimization of React "},{"title":"Preload","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#preload","content":"原先 Browser 有內建的資源優先等級，使用 preload，更進一步設定載入優先順序For CSS/JS/Font使用情境: CSS, 和牽涉到關鍵路徑的 JS 等重要資源 <link rel=\"preload\" as=\"script\" href=\"super-important.js\" /> <link rel=\"preload\" as=\"style\" href=\"critical.css\" /> <link rel=\"preload\" as=\"font\" crossorigin=\"anonymous\" type=\"font/woff2\" href=\"myfont.woff2\" /> Copy "},{"title":"Image","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#image","content":"Size# Reduce image to appropriate size convert image to appropriate format(WEBP, JPG) Lazy-Loading# with HTML (Can I use loading-lazy-attr) <img src=\"my-image.jpg\" loading=\"lazy\" /> Copy with JS (IntersectionObserver) 不讓圖片正常載入監視圖片元素，判斷它們是否進入到畫面中元素進入畫面後，再載入圖片範例 1: Lazy loading images using IntersectionObserver - example code範例 2: Lazy Loading background images in CSS 首次渲染的圖片不要做 Lazy Loading "},{"title":"Font","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#font","content":"確保在字體 loading 完成之前文字仍可見: font-face, CDN:＆display = swap  "},{"title":"Reference","type":1,"pageTitle":"Lighthouse Performance / Frontend Performance","url":"web-dev/web-lighthouse-performance#reference","content":"分析關鍵轉譯路徑效能禁止轉譯的 CSSApply instant loading with the PRPL pattern[教學] 深入淺出 Preload, Prefetch 和 Preconnect：三種加快網頁載入速度的 Resource Hint 技巧10 Proven Ways To Improve First Contentful Paint (FCP) in WordPressUnderstanding Speed IndexWeb - Timeline of a page load (Page Speed|Page Latency)10 Proven Ways To Improve First Contentful Paint (FCP) in WordPressUnderstanding Speed Index "},{"title":"Webpack Overview","type":0,"sectionRef":"#","url":"web-dev/webpack-overview","content":"","keywords":""},{"title":"Concepts","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#concepts","content":"Everything is a module (including, js, css, images, html) "},{"title":"Entry","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#entry","content":"the starting file to build dependency graph "},{"title":"Output","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#output","content":"where to emit the bundles it creates and how to name these files "},{"title":"Loader","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#loader","content":"Loaders are transformations that are applied to the source code of a module. Loaders work at the individual file level during or before the bundle is generated.Loaders allow you to pre-process files as you import or load them E.g.# babel-loader: Converts ES6+ JavaScript to ES5 using Babel.css-loader: Loads .css files to be used by other loaders. "},{"title":"Plugin","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#plugin","content":"A webpack plugin is a JavaScript object that has an apply method. This apply method is called by the webpack compiler, giving access to the entire compilation lifecycle.Plugins work at bundle or chunk level and usually work at the end of the bundle generation process. Plugins can also modify how the bundles themselves are created.  const pluginName = 'ConsoleLogOnBuildWebpackPlugin'; class ConsoleLogOnBuildWebpackPlugin { apply(compiler) { //accessing tap lifecycle compiler.hooks.run.tap(pluginName, (compilation) => { console.log('The webpack build process is starting!!!'); }); } } module.exports = ConsoleLogOnBuildWebpackPlugin; Copy Example: CSSO Webpack Plugin#  Plugins# terser-webpack-plugin: for Javascript minifyingmini-css-extract-plugin: for separating CSS into CSS file per JS file.  "},{"title":"Example: Bundling a static site","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#example-bundling-a-static-site","content":" In this case the plugins are only used for production. "},{"title":"webpack.config.js","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#webpackconfigjs","content":"Since webpack v4 the extract-text-webpack-plugin should not be used for css. Use mini-css-extract-plugin instead.babel-preset-es2015 -> babel-preset-envWebpack v5 comes with the latest terser-webpack-plugin out of the box. const path = require('path'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { entry: './src/main.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-react', '@babel/preset-env'] } } }, { test: /\\.css$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', // postcss-loader should load before css-loader { loader: 'postcss-loader', options: { // pass autoprefixer plugin plugins: [require('autoprefixer')], }, }, ], }, ], }, plugins: [new MiniCssExtractPlugin()], // terser-webpack-plugin config before webpack v4 minimizer: [ new TerserPlugin({ terserOptions: { mangle: { compress: {}, }, } }) ] }; Copy  "},{"title":"Development (webpack-dev-server + Hot Module Replacement)","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#development-webpack-dev-server--hot-module-replacement","content":"Webpack injects a whole lot of JS libraries to make HMR work.   Some file changed Webpack uses HotModuleReplacementPlugin to generate a manifest(a JSON containing list of changed modules) and an update file(a JS with the actual change info). Webpack then tells webpack-dev-server about the changes webpack-dev-server tells webpack-dev-server/client running in the browser via web socket by sending invalid notification via web socket. webpack-dev-server/client then sends the initial hash (e.g. b2e2d54372f42c1b2352) that it got when the app was first loaded to hot/dev-server library. hot/dev-server acts like the main interface to all other JS files. hot/dev-server then calls internal libraries(like JSONP runtime) that are also injected by Webpack to download the manifest file. JSONP runtime uses hash and loads the manifest file from the webpack-dev-server. The manifest file contains details about chunks that need to be uploaded to the browser. It’s file name looks like: b2e2d54372f42c1b2352.hot-update.json and it’s content looks like this: {“h”:”b3632c2a800d437e17df”,”c”:[0]} JSONP runtime then uses information contained inside the manifest file to load all the update chunks and adds them to the DOM. Updates JS themselves are JS files. They contain information about actual changes that needs to be applied. They are added to the DOM and executed. Updates call HMR runtime with the module id (e.g. moduleId 82 in the above example) and the actual changes. But HMR runtime itself doesn’t know how to deal with the changes. So it delegates this job to corresponding loaders like react-hot-loader runtimes or style-loader runtimes to apply changes. ( Note that these are also injected into the Browser. If there is no issues with applying the changes, the appropriate runtimes updates the module. If there are issues (like syntax errors in the change), hot/dev-server lib is notified about the error. "},{"title":"Reference","type":1,"pageTitle":"Webpack Overview","url":"web-dev/webpack-overview#reference","content":"Anatomy of a Static SiteAnalysis of Webpack HMR PrincipleWebpack & The Hot Module Replacement "}]